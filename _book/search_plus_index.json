{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction "},"BaseNode/负载流量/负载流量问题-题.html":{"url":"BaseNode/负载流量/负载流量问题-题.html","title":"负载流量","keywords":"","body":" 海量数据分析 用过哪些中间件。 API接口与SDI接口的区别（API是提供给别人的接口）。 做过工作流引擎没有 从系统层面考虑，分布式从哪些纬度考虑 虚拟机，IO相关知识点 秒杀系统的设计 说说项目中使用到的技术点，项目的总峰值qps，时延。 有没有分析过时延出现的耗时分别出现在什么地方，项目有啥改进的地方没有 如果请求出现问题没有响应，如何定位问题，说下思路？ 哪些数据是数据库和缓存双写一份的？ 双写一致性如何保证？保证一致性的同时如何保证高并发和性能？ 缓存线上是如何部署的？给了多大的总内存？命中率有多高？ 缓存抗了多少QPS？数据流回源会有多少QPS？ 是否某个key出现了热点缓存导致缓存集群中某个机器的负载过高？如何解决的？ 是否出现超大value打满网卡的问题？如何规避这个问题？ 线上是否出过缓存集群事故？如果出现了你们怎么解决有什么高可用保障预案？ 平时如何监控缓存集群的QPS和容量？如果要扩容该怎么扩？能否平滑扩容？扩容会导致系统需要停机吗？ 聊聊Redis的集群原理？扩容的时候会不会导致数据丢失？key寻址算法都了解哪些？ 你了解一致性hash算法吗？画个图说说Redis线程模型和内存模型？ 描述分布式事务之TCC服务设计？ 在面对未知的流量暴增，可以预先怎么处理 如何限流，限流算法，对于ddos攻击怎么处理 架构涉及 https://www.jianshu.com/p/9f985bbc9c70 怎么查看Linux服务器的负载，及判断哪些操作引起的负载过高 五种 I / 0 模型. epoll 、poll和selcet的区别。 一定要有拿的出手的项目经验，而且要能够讲清楚，讲清楚项目中取舍，设计模型和数据表。 常见问题定位一定要有思路。 fork命令是什么作用，开启一个shell界面对应什么操作。 "},"BaseNode/计算机/计算机底-答.html":{"url":"BaseNode/计算机/计算机底-答.html","title":"计算机-题目","keywords":"","body":"操作系统 人是CPU，程序是菜谱，进程就是 人做蛋糕，前台进程就是人的操作，后台进程就是比如微波炉傻的 进程 进程(process) 进程间通信 低级通信主要是进程间的同步，互斥，终止，挂起等控制信息 管道, 系统IPC(包括消息队列,信号量,共享存储), SOCKET. 高级通信有管道(PIPE)、消息队列(MESSAGE)、共享内存(SHARED MEM0RY) 高级通信有管道(PIPE)-需要在内核和用户空间进行四次的数据拷贝 管道通信方式的中间介质就是文件(管道文件),读写文件连在一起跟管道一样,是半双工的方式 无名通道:只能在亲缘关系的进程中进行传输. 有名通道，可以在任意进程中进行传输. 消息队列(MESSAGE)-需要在内核和用户空间进行四次的数据拷贝 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 共享内存(SHARED MEM0RY) 共享内存则只拷贝两次数据 映射一段能被其他进程所访问的内存，由进程创建。使用的是最快的ipc方式 缺点：需要自己做互斥 信号量 信号量是一个计数器，它用来记录对某个资源（如共享内存）的存取状况 不能传递复杂消息，只能用来同步 信号 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 套接字( socket ) ： 套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。 管程；管理进程 各种通信方式的比较和优缺点： 无名管道：速度慢，容量有限，只有父子进程能通讯 有名管道（named pipe）：任何进程间都能通讯，但速度慢 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题 信号量：不能传递复杂消息，只能用来同步 共享内存：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存 进程的调度算法 最短工作优先（SJF）； 非抢占 最短剩余时间优先（SRTF）；非抢占 最高响应比优先（HRRF）；抢占 优先级调度（Priority）；抢占 轮转调度（RR）抢占 前台进程和后台进程的区别 后台比如crontab 守护进程 区别1,前台进程你可以操作,后台进程你不能操作(除了把它关闭). 区别2,前台进程不全是由计算机自动控制,后台进程全都是由计算机自动控制. 特征1,前台进程可以以窗口,对话匡的形式在系统中显示.后台进程不行. 在任务栏中点亮的进程都可以称为前台进程.没点亮的为后台进程. 前台进程和后台进程有时候可以互相转换. 进程同步机制 临界区、 任意时刻只允许一个进程对共享资源进行访问，其他进程被挂起，等到进入临界区的进程离开，才可以抢占。 互斥区、 互斥对象机制。 只有拥有互斥对象的进程才有访问公共资源，因为互斥对象只有一个，保证公共资源不会同时被多个进程访问。一个进程内的线程 事件、轮流 过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作 . 信号量 等通知 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 kill函数的每一个参数的作用？ Pid>0：发给ID为pid的进程Pid=0：发给进程组所有的进程 Pid=-1：发给所有的进程 Pid 僵死进程，孤儿进程 孤儿： 概念：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。 逻辑：init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。 守护进程数init的孤儿进程 僵死： 概念：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。 查看僵尸进程：ps -ef|grep defunct 危害： 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。 直到父进程通过wait / waitpid来取时才释放。 但这样就导致了问题，如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。 进程数量有限 ，如果一直占用的话,杀死生产问题进程 创建进程的步骤？ （1）申请空的PCB 进程控制块 （2）为新进程分配资源（ 3）初始化PCB （4）将新进程插入就绪队列中 进程切换发生的原因？处理进程切换的步骤？ 原因：中断发生；更高优先级进程唤醒；进程消耗完了时间片；资源阻塞； 步骤：（1）保存处理器的上下文（2）用新状态和其它相关信息更新正在运行进程的PCB（3）将原来的进程移到合适的队列中【就绪，阻塞】（4）选择另外一个执行的进程，更新被选中进程的PCB，将它加载进CPU 守护进程 怎么实现 父进程fork出子进程并exit退出 子进程调用setsid创建新会话 子进程调用系统函数chdir将根目录\"/\"成为子进程的工作目录 子进程调用系统函数umask将该进程的umask设置为0 子进程关闭从父进程继承的所有不需要的文件描述符 线程 线程(thread) 通俗：让原来要使用异步+回调方式写的非人类代码,可以用看似同步的方式写出来. 线程间通信 锁机制：包括互斥锁、条件变量、读写锁 互斥锁提供了以排他方式防止数据结构被并发修改的方法。 读写锁允许多个线程同时读共享数据，而对写操作是互斥的。 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量 信号机制(Signal)：类似进程间的信号处理 线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。 线程的几种状态 新建状态,就绪状态（Runnable）,运行状态（Running）,阻塞状态（Blocked）：,死亡状态（Dead） 单核CPU中的线程会有线程安全问题吗？ 即使单 cpu，操作系统也会按时间分片模拟出多核并发的效果，所以会有(程序a,b互相抢占) 确保线程安全的几种方式？ （1）原子操作 （2）同步与锁 （3）可重入 （4）阻止过度优化volatile 进程与线程的区别？ 进程有自己的独立地址空间，线程没有 进程是资源分配的最小单位，线程是CPU调度的最小单位 进程和线程通信方式不同 进程切换上下文开销大，线程开销小 一个进程挂掉了不会影响其他进程，而线程挂掉了会影响其他线程 对进程进程操作一般开销都比较大，对线程开销就小了 协程是非抢占式的 进程/线程同步机制 和 进程间通信机制比较 同步主要是临界区、互斥、信号量、事件 进程间通信是管道、内存共享、消息队列、信号量、socket 共通之处是，信号量和消息（事件）是进/线的共同同步方法 管程是进程同步的方式，而管道则是进程通信的方式 进程间通信机制中唯一的异步通信机制 协程 (Coroutine) 概念 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。 协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常块。 有没有了解过协程？说下协程和线程的区别？ 一个线程可以多个协程，一个进程也可以单独拥有多个协程。 线程进程都是同步机制，而协程则是异步。 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。 Coroutine是编译器级的 操作系统 传统内存 缺点：很多用不到的数据也会长期地占用内存，导致内存利用率不高。 一次性：作业必须一次性全部装入内存后才能开始运行-(比如大型的游戏) 驻留性:一旦作业被装入内存，就会一直驻留在内存中 只需访问作业的一小部分数据即可正常运行 虚拟内存， 概念：局部性原理 时间局部性:如果一个命令被执行过，那么之后还可能被执行 方便循环 空间局部性:如果访问过某个内存单元，那么之后还可能被执行 虚拟内存实现有哪几种方式？有什么意义？ 意义概念 ： 将近期会频繁访问到的数据存放到更高速的存储器中，暂时用不到的数据放在更低速存储器中。 层级 寄存器 > 高速缓存 > 内存 > 磁盘 程序执行过程中，内存不在的数据要调入，内存不够要清除出去 请求方式-对应进程5算法 请求分页存储管理； 请求分段存储管理； 请求段页式存储管理 分段分页， 一个段标识符加上一个指定段内相对地址的偏移量 使得进程的物理地址空间可以是非连续的。分页 请求页面置换策略有哪些方式？他们的区别是什么？各自有什么算法解决？ 全局和局部； 全局：在整个内存空间置换 局部：在本进程中进行置换 全局：（1）工作集算法（2）缺页率置换算法 局部：（1）最优算法（2）FIFO先进先出算法（3）LRU最近最久未使用（4）时钟算法 缺页调度的流程。 FIFO、LRU、OPT这三种置换算法 死锁 https://zhuanlan.zhihu.com/p/57791070 概念： 各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。 对待死锁的策略， 死锁预防，四个一个失败就行 互斥条件 只有对必须互斥使用的资源的争夺才会导致死锁（如哲学家的筷子，打印机设备）。向内存，扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源） 不可剥夺条件 不能由其他进程强行夺走，只能主动释放。 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占用，此时请求进程被阻塞，但又对自己已有的资源保持不放。 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被下一个进程所请求 死锁避免（银行家算法）， 在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。 如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。 磁盘的寻道算法。 FIFO：先来先服务算法； SSTF： 最短寻道时间算法；利用贪心算法来实现 SCAN：电梯调度算法；(这样命名很形象) CSCAN： 循环扫描算法 FSCAN：分步电梯调度算法(分两个队列) 用户态和内核态 概念 内核态：特殊的软件程序，是控制计算机的硬件资源，例如协调CPU资源，分配内存资源，并且提供稳定的环境供应用程序运行。 提供应用程序运行的空间，为了使应用程序访问到内核管理的资源例如CPU，内存，I/O Linux操作系统就将权限等级分为了2个等级，分别就是内核态和用户态。 防止资源过渡分配 调用方式 系统调用，这个上面已经讲解过了，在我公众号之前的文章也有讲解过。其实系统调用本身就是中断，但是软件中断，跟硬中断不同 异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，就会触发切换。例如：缺页异常。 外设中断：当外设完成用户的请求时，会向CPU发送中断信号。 为啥在用户态和内核态之间切换调度成本比较高？ 从一个软件换用另一个软件————控制计算机的硬件资源，并提供上层应用程序运行的环境。 应用程序 > shell/公共函数 > 系统调用 > 内核 系统调用与函数调用的区别？ （1）一个在用户地址空间执行；一个在内核空间执行 （2）一个是过程调用，开销小；一个需要切换用户空间和内核上下文，开销大 （3）一般相同；不同系统不同 cpu 资源占用 us/sy/si 各代表什么意思 us 用户空间占用CPU百分比 sy 内核空间占用CPU百分比 ni 用户进程空间内改变过优先级的进程占用CPU百分比 select 和epoll select是IO多路复用的系统调用，内核同时监听多个句柄，一旦有句柄可用就通知进程。进程轮询之前关注的句柄集合，开始执行io操作。 epoll是Linux系统特有的系统调用，内核基于红黑树维护一个已就绪句队列，不用轮询查找，直接使用，效率更高。 Select，poll和epoll的区别？为什么？Select和poll缺点： 每次调用select都需要将fd集合从用户态拷贝到内核态 每一次调用select都需要在内核中遍历所有的fd select支持的文件句柄,默认1024，poll没有限制 Epoll：使用红黑树来存储fd，同时每一次通过epoll__ctl来将fd加入内核中，同时通过双向列表来返回已经出发某一个事件的fd 进程线程的区别https://juejin.im/post/5e5cb893f265da570d736388 进程模型：https://juejin.im/post/5e5e080e6fb9a07cb0315a49 linux内存管理：https://juejin.im/post/5e633173518825494707f014 "},"BaseNode/计算机/计算机底-题.html":{"url":"BaseNode/计算机/计算机底-题.html","title":"计算机-答案","keywords":"","body":"操作系统 人是CPU，程序是菜谱，进程就是 人做蛋糕，前台进程就是人的操作，后台进程就是比如微波炉傻的 进程 进程(process) 进程间通信 低级通信主要是 通信方式哪些 介绍下管道类型和含义 消息队列(MESSAGE) 共享内存(SHARED MEM0RY) 的优缺点 信号量是什么 信号是什么 套接字( socket ) 是什么 管程？ 各种通信方式的比较和优缺点： 管道： 有名管道（named pipe）： 消息队列： 信号量： 共享内存： 进程的调度算法哪些 实际应用中哪些用到了线程通信和进程通信 前台进程和后台进程的区别 进程同步机制 临界区 互斥区 事件、轮流 信号量 等通知 进程/线程同步机制 和 进程间通信机制比较 进程间通信机制中唯一的异步通信机制 僵死进程，孤儿进程 孤儿： 概念： 逻辑： 守护进程数init的孤儿进程 僵死： 概念： 查看僵尸进程： 危害： 守护进程 怎么实现 线程 线程(thread) 线程间通信 锁机制：包括互斥锁、条件变量、读写锁 信号量机制(Semaphore)： 信号机制(Signal)： 线程的几种状态 单核CPU中的线程会有线程安全问题吗？ 确保线程安全的几种方式？ 进程与线程的区别？ 协程 (Coroutine) 概念 有没有了解过协程？说下协程和线程的区别？ Coroutine是编译器级的 操作系统 传统内存 缺点： 一次性： 驻留性: 虚拟内存， 概念： 时间局部性: 空间局部性: 虚拟内存实现有哪几种方式？有什么意义？ 意义概念 ： 层级 程序执行过程中， 请求方式-对应进程5算法 请求分页存储管理； 请求分段存储管理； 请求段页式存储管理 分段分页， 缺页调度的流程。 死锁 https://zhuanlan.zhihu.com/p/57791070 概念： 对待死锁的策略， 死锁预防，四个一个失败就行 互斥条件 不可剥夺条件 。 请求和保持条件： 循环等待条件： 死锁避免（银行家算法）， 磁盘的寻道算法。 用户态和内核态 概念 内核态： 用户态： 调用方式 系统调用， 异常： 外设中断： 为啥在用户态和内核态之间切换调度成本比较高？ "},"BaseNode/网络协议/网络协议-答.html":{"url":"BaseNode/网络协议/网络协议-答.html","title":"网络协议-答","keywords":"","body":" OSI七层模型？ 应用层；表示层；会话层；传输层；网络层；数据链路层；物理层； DHCP协议是什么？使用什么端口？他的优劣？ 动态主机配置协议 客户端端口：68；服务端端口：67 如果发生IP冲突则返回DHCP decline 网络序是大端还是小端？为什么要这样？ 主机序：不同的CPU有不同的字节序类型 整数在内存中保存的顺序 这个叫做主机序 网络序：是TCP/IP中规定好的一种数据格式，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传 网络序是大端的，按内存增长的顺序,高位数据存在低内存中 大端 操作系统原理，套接字 操作系统内容，操作系统调用系统函数，访问系统内核或设备会返回一个fd句柄，根据句柄来获取操作。 套接字 TCP套接字是由一个四元组（源IP地址、源端口号，目的IP地址，目的端口号）来标识的 操作系统网络，系统会为我们创建一个套接字Socket，并返回这个Socket的ID，操作网络只要向这个Socket的编号ID操作即可。每一个网络通信的进程至少对应着一个Socket。向Socket的ID中写数据，相当于向网络发送数据，向Socket中读数据，相当于接收数据。而且这些套接字都有唯一标识符——端口号。 应用层协议： 1、超文本传输协议（HTTP）:万维网的基本协议； 2、文件传输（FTP简单文件传输协议）； 3、远程登录（Telnet），提供远程访问其它主机功能, 它允许用户登录internet主机，并在这台主机上执行命令； 4、网络管理（SNMP简单网络管理协议），该协议提供了监控网络设备的方法， 以及配置管理,统计信息收集,性能管理及安全管理等； 5、域名系统（DNS），该系统用于在internet中将域名及其公共广播的网络节点转换成IP地址。 网络层 1、Internet协议（IP）； 2、Internet控制信息协议（ICMP）； 3、地址解析协议（ARP）； ARP协议。 地址解析协议， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址。 上层应用程序更多关心IP地址而不关心MAC地址，所以需要通过ARP协议来获知目的主机的MAC地址，完成数据封装。 4、反向地址解析协议（RARP）。 概念 IP 地址子网划分。5类 A类 1.0.0.0 掩码8 B类 128.0.0.0 掩码16 C类 192.0.0.0 掩码24 Mac 地址 物理地址/硬件地址，固定不变，在链路层，十六进制长度是6个字节（48位），分为前24位和后24位。 IP地址与MAC地址区别 长度不同：IP地址为32位（二进制），MAC地址为48位（十六进制）。 分配依据不同：IP地址的分配是基于网络拓扑，MAC地址的分配是基于制造商。 寻址协议层不同：IP地址应用于OSI第三层（网络层），而MAC地址应用在OSI第二层（数据链路层）。 硬链接和软连接区别 硬链接：linux下的文件是通过索引节点（Inode）来识别文件，硬链接是一个指针，指向文件索引节点，系统并不为它重新分配inode。每添加一个一个硬链接，文件的链接数就加1。 不足之处：（1）不可以在不同文件系统的文件间建立链接（2）只有超级用户才可以为目录创建硬链接。 软连接 软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。 用户数据，元数据 (metadata)。 用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方； 元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。才是文件的唯一标识而非文件名 DNS 解析过程。 DNS: 客户端以udp的数据包形式发送 本地host是否存在映射 本地不存在映射->查询本地->根域名->顶级->二级->权威 dns迭代和递归的区别? 递归是用户只向本地DNS服务器发出请求，然后等待肯定或否定答案。本地dns会问其他服务然后返回答案 迭代是本地服务器向根DNS服务器发出请求，而根DNS服务器只是给出下一级DNS服务器的地址，然后本地DNS服务器再向下一级DNS发送查询请求直至得到最终答案。 kill 用法，某个进程杀不掉的原因（进入内核态，忽略 kill 信号） 僵死进程->详见进程 进入内核态，忽略所有信号 RPC相对于传统的API调用的优点 HTTP 请求有用的信息少，头太多,普通话，大而全 RPC，序列化数据，是json和xml，地方化，专业精准 fork如何区分父子进程 父进程从fork()返回时的返回值是子进程的进程号，非零； 知道什么是幂等性吗？举个例子？ 防重点击：其任意多次执行所产生的影响均与一次执行的影响相同。 比如select,delete,唯一索引，各种锁，状态机 VPN的实现原理是什么 虚拟私有网络。,打隧道，做路由的过程！ Linux 路由表一般包含什么？ （1）网络地址（2）网络掩码（3）网关【下一跳服务器】（4）跃点数【距离】 ping命令的实现原理，ping命令为什么不需要端口号呢? ICMP协议查看远程服务器的原理。 原理是向指定的IP地址发送一定长度的数据包，成功返回，时间内失败超时 ICMP协议:“Internet Control Message Protocol”（Internet控制消息协议），是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息 ICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。 TCP/UDP TCP 概念 TCP/IP提供了点对点链接的机制，将数据应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。、 它将软件通信过程抽象化为四个抽象层（包括应用层,传输层，网络层，网络访问层。）， 采取协议堆栈的方式，分别实现出不同通信协议。 名称解释 序列号seq： 序列号seq就是这个报文段中的第一个字节的数据编号。 确认号ack： 报文段最后一个字节的编号+1即为确认号。 确认ACK： 仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效 同步SYN： 连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。 终止FIN： 用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接 TCP-传输控制协议 过程 第一次握手：主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B，向主机B 请求建立连接，通过这个数据段， 主机A告诉主机B 两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我。 第二次握手：主机B 收到主机A的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机A，也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我 TCP如果两次握手会出什么问题？ 两次握手：客户端发送的连接请求可能在网络中滞留了，如果没有三次握手，可能会再次创建一个连接。 第三次握手：主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B 的数据段：\"我已收到回复，我现在要开始传输实际数据了，这样3次握手就完成了，主机A和主机B 就可以传输数据了。 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？ 第三次握手时候，客户端发送一个finsh报文，服务端回复ack应答， 当数据传输完成后，才会发送一个finsh完成包给客户端，客户端关闭连接 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 最大报文生存时间 服务端最后一次ack 可能丢失 ，所以需要这个time_wait等待防止丢失 可以重发。 Tcp为什么可以保证传输的可靠性 应用数据被分割成TCP认为最适合发送的数据块。这和UDP完全不同，应用程序产生的数据报长度将保持不变 (将数据截断为合理的长度) 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。 tcp怎么保证有序传输的， TCP就给每个数据包分配一个序列号并且在一个特定的时间内等待接收主机对分配的这个序列号进行确认，如果发送主机在一个特定时间内没有收到接收主机的确认，则发送主机会重传此数据包。接收主机利用序列号对接收的数据进行确认，以便检测对方发送的数据是否有丢失或者乱序等，接收主机一旦收到已经顺序化的数据，它就将这些数据按正确的顺序重组成数据流并传递到高层进行处理 超时重传 连接管理：三次握手与四次挥手的过程 流量控制 拥塞控制 tcp拥塞机制-（慢开始，拥塞避免，超时重传，快速重传/快速恢复算法） 计算机网络中的带宽、交换节点中的缓存和处理机等，都是网络的资源，在某段时间内，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏，这种情况就叫做拥塞。 拥塞控制，就是防止过多的数据注入到网络中，拥塞控制是一个全局性的过程，涉及到所有的 拥塞控制的算法有： 慢开始:慢开始算法的核心是从小到大逐渐增大发送窗口，cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。 拥塞避免：让拥塞窗口缓慢地增大，收到每一轮的确认后，将拥塞窗口的值加1，而不是加倍，这样拥塞窗口的值按照线性规律缓慢增长。 超时重传：发送一个数据以后就开启一个计时器，在一定时间内如果没有得到发送数据报的ACK报文，那么就重新发送数据，直到发送成功为止 这是数据包丢失的情况下给出的一种修补机制 快速重传/快速恢复算法：一般来说，重传发生在超时之后，但是如果发送端接收到3个以上的重复ACK，而快速重传以后，因为走的不是慢启动而是拥塞避免算法，所以这又叫做快速恢复算法。 PS:没有快速重传和快速恢复，TCP将会使用定时器来要求传输暂停,在暂停这段时间内，没有新的数据包被发送。 TCP协议通过使用连续ARQ协议和滑动窗口协议，来保证数据传输的正确性，从而提供可靠的传输。 ARQ协议 即自动重传请求（Automatic Repeat-reQuest），是OSI模型中数据链路层和传输层的错误纠正协议之一。ARQ包括停止等待ARQ协议和连续ARQ协议， 停止等待协议 超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。 优点是简单,但是缺点是信道的利用率太低,一次发送一条消息,使得信道的大部分时间内都是空闲的, 因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。 缺点：停止等待ARQ协议的优点是简答，但也有很严重的确定，就是信道利用率太低 连续ARQ协议: 连续确认ARQ和滑动窗口是配合一起使用的： 连续发出5个数据包，接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了，提高信道利用率 但是如果缺少了其中一个是需要将其他的全部重发，当通信质量不是很好的时候,连续ARQ还是会带来负面影响. 滑动窗口协议:之所以叫滑动窗口协议,是因为窗口是不断向前走的,该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输,还可以控制流量的问题. ARQ协议 机制 拥有错误检测（Error Detection）、 正面确认（Positive Acknowledgment）、 超时重传（Retransmission after Timeout）和 负面确认及重传（Negative Acknowledgment and Retransmission）等机制 8. tcp 粘包问题怎么处理？ 1. TCP是一个基于字节流的传输服务，\"流\"意味着TCP所传输的数据是没有边界的 2. 产生粘包问题的原因有以下几个： 1. 如果发送方发送的多个分组本来就是同一个数据的不同部分，比如一个很大的文件被分成多个分组发送，这时，当然不需要处理粘包的现象； 2. 但如果多个分组本毫不相干，甚至是并列的关系，我们就一定要处理粘包问题了。 3. 粘包的问题的解决思路 1. 粘包问题的最本质原因在与接收对等方无法分辨消息与消息之间的边界在哪。 2. 粘包解决方案一：使用定长包，如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。 3. 粘包解决方案二：使用结构体，显式说明数据部分的长度，包尾加上\\r\\n标记。FTP协议正是这么做的。但问题在于如果数据正文中也含有\\r\\n，则会误判为消息的边界。 4. 粘包解决方案三：按行读取，ftp协议采用/r/n来识别一个消息的边界，我们在这里实现一个按行读取的功能，该功能能够按/n来识别消息的边界。这里介绍一个函数： 1. 那三次握手又会造成什么问题？有什么好的解决方法没？ 1. 三次握手：引起SYN flood DOS攻击 1. 在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。 2. SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。 3. 检测 SYN 攻击非常的方便，半连接状态，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。 4. SYN攻击不能完全被阻止，常见的防御 SYN 攻击的方法有如下几种 1. 增加积压队列 2. 回收最早的半开TCP连接: 增加最大半连接数，”伤敌一千，自损八百“ 3. SYN cookie：把发送ack的请求缓存住，并且删除缓冲队列里的请求，等确认是合法的后回复这个请求 2. UDP 1. 概念 1. UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，传送时抓取来自应用程序的数据，并扔到网络上 2. UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。 3. 一台服务机可同时向多个客户机传输相同的消息。 4. UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。 5. UDP是面向报文的 6. ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包， 如果数据包是否到达的消息及时反馈回来，那么网络就是通的。 7. 包头都是16位 2. UDP应用场景： 1. 面向数据报文方式 2. 网络数据大多为短消息 3. 拥有大量Client 4. 对数据安全性无特殊要求 5. 网络负担非常重，但对响应速度要求高 3. udp是不可靠的传输，如果你来设计一个基于udp差不多可靠的算法，怎么设计？ 1. 特点 1. Tcp 面向连接，提供可靠的传输； UDP面向无连接，提供不可靠传输 2. Tcp 提供流量控制 ； UDP不提供流量控制 3. Tcp 保证传输数据顺序 ； UDP不保证传输顺序，也就是可能是乱序收包 4. TCP 面向字节流 ； UDP 面向数据包 2. 设计思路 1. 数据完整性 –> 加上一个16或者32位的CRC验证字段 2. 乱序 –> 加上一个数据包序列号SEQ 3. 丢包 –> 需要确认和重传机制，就是和Tcp类似的Ack机制 4. 协议字段 –> protol 字段，标识当前使用协议 3. 小结TCP与UDP的区别： 1. TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接 2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付 3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的 4. UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等） 5. 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信 6. TCP首部开销20字节;UDP的首部开销小，只有8个字节 7. TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道 12. 应用场景 1. TCP应用场景:效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。 2. UDP应用场景 1. 效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播） time_wait状态，这个状态出现在什么地方，有什么用？ time_wait状态 保证TCP协议全双工连接能够可靠关闭，直接关闭的话，如果服务器没有收到ACK，会重复发FIN 保证连接的重复数据从网络中消失，如果上次的socket和这次的socket处理的程序一样，就会导致这次连接把上次的数据加进来了。 假设最终的ACK丢失，主机2将重发FIN，主机1必须维护TCP状态信息以便可以重发最终的ACK，否则会发送RST，结果主机2认为发生错误。 TCP实现必须可靠地终止连接的两个方向(全双工关闭)，主机1必须进入 TIME_WAIT 状态，因为主机1可能面 临重发最终ACK的情形。 产生大量TIME_WAIT的原因 某些服务如pop/smtp、ftp 客户端程序忘记关闭连接，也会出现TIME_WAIT的状态。 一般情况服务器端不会出现TIME_WAIT状态，因为大多数情况都是客户端主动发起连接并主动关闭连接 出现太多TIME_WAIT可能导致的后果 持续的到达一定量的高并发短连接，会使服务器因端口资源不足而拒绝为一部分客户服务。 而端口有个0~65535的范围，并不是很多，刨除系统和其他服务要用的，剩下的就更少了。 TIME_WAIT太多怎么解决? 解决发起端的IP地址,添加更多的IP(time_wait多的服务器) 改用长链接方式 让TIME_WAIT早点过期，修改配置 close_wait过多该如何解决。 https://blog.csdn.net/lishenglong666/article/details/45335589 在被动关闭连接情况下，在已经接收到FIN，但是还没有发送自己的FIN的时刻，连接处于CLOSE_WAIT状态。 出现大量close_wait的现象，主要原因是某种情况下对方关闭了socket链接，但是我方忙与读或者写，没有关闭连接。代码需要判断socket，一旦读到0，断开连接，read返回负，检查一下errno，如果不是AGAIN，就断开连接。 TCP 保活机制（SO_KEEPALIVE 超时重发 RTT，RTO RTT:一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值, RTO:重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传, RTO协议实现值最小1s 底层的网络是不可靠的 信道利用率太低，每次都需要等上一次ACK包接收到了才能再次发送 HTTP/https http与https有啥区别？说下https解决了什么问题，怎么解决的？说下https的握手过程。 区别 https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。前者是80，后者是443 HTTPS协议握手阶段比较费时，缓存资源 https过程 客户端发起HTTPS请求 服务端的配置，增加证书，私钥，公钥 传送证书 客户端解析证书 传送加密信息 服务段解密信息 传输加密后的信息 客户端解密信息 搜索引擎对HTTPS的态度 HTTPS要比HTTP多用多少服务器资源？ HTTP使用TCP三次握手建立连接，客户端和服务器需要交换3个包 HTTPS除了TCP的三个包，还要加上ssl握手需要的9个包，所以一共是12个包。 HTTP请求过程（从URL输入到页面展现发生什么？） DNS解析过程 拿到ip后使用 ARP地址解析协议协议，拿到目标IP对应的MAC地址，完成数据封装 经过osi七层协议，物理层、数据链路层、网络层、传输层、会话层、表示层和应用层 web服务器，返回数据 传输完成，第三次握手挥手关闭请求 Http1.0与1.1区别 缓存处理， HTTP1.0 header里的If-Modified-Since,Expires来做为缓存判断的标准， HTTP1.1 更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。 带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。 长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。 Http2.0的特性 二进制分帧 首部压缩 流量控制 多路复用 请求优先级 服务器推送 "},"BaseNode/网络协议/网络协议-题.html":{"url":"BaseNode/网络协议/网络协议-题.html","title":"网络协议-题","keywords":"","body":" DHCP 子网掩码分5类 IP地址与MAC地址区别 网络序是大端还是小端？为什么要这样？ 操作系统原理，套接字 应用层协议： OSI七层模型？ 硬链接和软连接区 用户数据，元数据 (metadata)。 dns解析过程 kill 用法，某个进程杀不掉的原因（进入内核态，忽略 kill 信号） RPC相对于传统的API调用的优点 fork如何区分父子进程 知道什么是幂等性吗？举个例子？ VPN的实现原理是什么 路由表一般包含什么？ ping命令的实现原理，ping命令为什么不需要端口号呢? tcp 过程 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？ 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？ Tcp为什么可以保证传输的可靠性 tcp拥塞机制 ARQ协议 tcp 粘包问题怎么处理？ 那三次握手又会造成什么问题？有什么好的解决方法没？ tcp/udp的区别 UDP应用场景： udp是不可靠的传输，如果你来设计一个基于udp差不多可靠的算法，怎么设计？ 小结TCP与UDP的区别： time_wait状态，这个状态出现在什么地方，有什么用？ time_wait状态 产生大量TIME_WAIT的原因 出现太多TIME_WAIT可能导致的后果 TIME_WAIT太多怎么解决??? RTT，RTO TCP协议通过使用连续ARQ协议和滑动窗口协议，来保证数据传输的正确性，从而提供可靠的传输。 Http1.0与1.1区别 http与https有啥区别 说下https解决了什么问题，怎么解决的？说下https的握手过程。 http请求过程 http2.0的特点 "},"BaseNode/Linux/常见.html":{"url":"BaseNode/Linux/常见.html","title":"Linux","keywords":"","body":"Linux操作命令 如何查看进程，如何查看线程，如何查看某个进程的线程,top -H [-p pid], ps -T [-p pid]。 如何查看内存使用状况。 如何查看磁盘的使用状况。df -h 查看目录的使用状况。du -sh 查看某个端口的使用状况。lsof -i:8088 实时的查看日志文件。tailf -n 50 [fileName] 查看某个日志文件中的内容。grep -i \"xxx\" file 不想查看文件中的内容。grep -v \"xxx\" file，不想查看多个内容 grep -v \"xxx | yyy\" file 取文件的前50行。head -n 50 file 查看文件的多少行。wc -l filename 分割一个文件，以1000行为一个文件。spilt -l 1000 filename -d -a 5 将一个文件中的A全部替换成B 。在命令行模式下 输入%s/A/B/g 动态的查看进程状态，watch -nl \"ps -ef\" 或者 top "},"BaseNode/Mysql/Mysql知识点-题.html":{"url":"BaseNode/Mysql/Mysql知识点-题.html","title":"Mysql-答","keywords":"","body":" 范式 Mysql和inno的一些概念 mysql组成-一个实例可能多个数据库，也可能1对1-一个单进程多线程架构的数据库 ，一个进程一个实例 Inno引擎 Inno后台线程：体系架构(缓存池) 内存 缓冲池 内存区域进行管理 数据结构 索引 哈希索引（InnoDB 自适应）； 为什么使用b+树 Cardinality 聚簇索引/非聚簇索引； 联合索引； 覆盖索引； 索引优缺点 索引无法使用的情况 事务 事务是如何实现的 ACID特性； 事务的并发问题（第一二类丢失更新，脏读，不可重复读，幻读）； 隔离级别（读未提交，读已提交，可重复读，串行化）； 数据库锁 查看思维导图 数据库锁的类别（）； 乐观锁: 悲观锁/更新锁: 读锁(共享锁): 写锁(排他锁) 通常所说的“一锁二查三更新”即指的是 表锁： 行锁： 行锁优化 行锁原理 意向锁: （解决行表锁冲突）， 意向共享锁 意向排他锁 记录锁 间隙锁 Next-Key锁 死锁 概念：主 发生情况 死锁产生的必要条件 实现 处理死锁的四种方法： 加锁协议（一/二/三级加锁协议，二段锁协议（充分条件），一次封锁法等）； 两段锁协议: S2PL: 2PC， OLTP与OLAP的介绍 MVCC 的概念，时间戳版本号，快照版本与当前版本，适用场景等。 mysql分表 分表策略 RANG 从0到10000一个表，10001到20000一个表； 分库分表后怎么保证主键仍然是递增的? 分表的查询分页,利弊,分表下不同查询维度如何实现，最终引导除了双向表，得出分表了一个弊端，即数据冗余 慢查询、执行计划、sql优化 慢查询：超过参数：long_query_time时间的sql-https://www.cnblogs.com/clschao/articles/10463743.html#part_1 slow_query_log 启动停止技术慢查询日志 slow_query_log_file 指定慢查询日志得存储路径及文件（默认和数据文件放一起） long_query_time 指定记录慢查询日志SQL执行时间得伐值（单位：秒，默认10秒） log_queries_not_using_indexes 是否记录未使用索引的SQL log_output 日志存放的地方【TABLE】【FILE】【FILE,TABLE】 explain计划 顺序 ID列： select_type列: table列: Type列: possible_keys: key_len: Ref: Extra列 工程问题 https原理（握手过程） http1和http2有什么区别，http2优势 http常见返回码及其含义 http缓存控制，协商缓存相关的几个头部的之间的优先级关系 什么是cors？为什么要用cors？ xss是什么？如何防范？具体例子，jsonp如何防止xss？ cookie有什么用？存在什么问题？如何解决？crsf如何防范？ dns寻址过程？简述cdn原理 "},"BaseNode/Mysql/Mysql知识点-答.html":{"url":"BaseNode/Mysql/Mysql知识点-答.html","title":"Mysql-题","keywords":"","body":"关系数据库 范式 要求有主键，并且要求每一个字段原子性不可再分 即主键唯一，字段不要有137，138这种 要求所有非主键字段完全依赖主键，不能产生部分依赖 多对多关系不在一张表里 所有非主键字段和主键字段之间不能产生传递依赖 学生id ->班级id -> 班级名称不行Mysql和inno的一些概念 mysql组成-一个实例可能多个数据库，也可能1对1-一个单进程多线程架构的数据库 ，一个进程一个实例 连接池组件 管理服务和工具组件 SQL接口组件 查询分析器组件 优化器组件 缓冲（Cache）组件 插件式存储引擎 物理文件 Inno引擎 Inno后台线程：体系架构(缓存池) Master Thread:主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO页的回收等。2.5节会详细地介绍各个版本中Master Thread的工作方式。 IO Thread:使用了AIO（Async IO）来处理写IO请求，这样可以极大提高数据库的性能 Purge Thread:事务被提交后，其所使用的undolog可能不再需要，因此需要PurgeThread来回收已经使用并分配的undo页 Page Cleaner Thread:其作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成。而其目的是为了减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能。 内存 缓冲池 基于磁盘存储，以分页的形式 缓冲池的大小直接影响着数据库的整体性能。由于32位操作系统的限制，在该系统下最多将该值设置为3G。 强烈建议数据库服务器都采用64位的操作系统。innodb_buffer_pool_size来设置 内存区域进行管理 缓冲池是通过LRU（Latest Recent Used，最近最少使用 数据结构 1. B+ 树的好处 索引 1. 为什么使用b+树 1. 单一节点存储更多元素，减少IO，非叶子节点只是存储key，占用空间非常小方便直观 2. 所有查询都要找到叶子节点，查询稳定 3. 所有叶子节点形成有序链表，方便范围查询,而且对应物理磁盘的指针顺序 2. 哈希索引； 1. 哈希自适应索引 InnoDB特性: 1. 插入缓存， 2. 2次写入， 3. 哈希自适应索引 4. 异步I/O 5. 刷新领接页 2. 优先主键是哈希，因为inno的数据是基于主键索引上，并且领接页面是有序的，对应磁盘上的位置 3. 如果没主键，那么第一个非空唯一索引是主键 4. 如果都没有，会自动创建一个字节为6的隐藏主键当聚集哈希索引 3. 聚簇索引/非聚簇索引； 1. innoDB是B+树的数据结构，叶子节点上的都是整行数据,聚集索引直接通过键值找到叶子节点上的数据,索引数据和物理数据顺序是一致的不能2个 2. 非聚集索引是通过非聚索引的键值找到节点上的值，在找到行数据. 4. Cardinality 1. show index from xxx表， 其中Cardinality /行数 越接近1那么索引效果越好,但是这是一个预估值 2. 原理是通过随机抽取8个数据节点算出来的 3. 算法是：非叶子节点数量N 对应节点数量是p1~p8 那么公示就是Cardinality=（p1+p...+p8）* n/8 4. 数据变化超过1/16时候，或者配置项变更超过200W次 5. 联合索引； 1. 不同二级索引区别，是有多个索引项s 2. 联合索引也是一个B+树 3. ab查询ok a查询ok b查询不ok 4. 联合索引ab的b是排序好的，如果用联合索引进行排序可以减少排序成本 6. 覆盖索引； 1. 最左匹配情况下，一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。Extra有Using index 数据全走索引 2. select 和where都走到索引，不需要回表在查询数据 减少io 7. 索引优缺点（加快检索速度，加快多表连接，额外空间开销，维护索引的额外时间开销）； 1. 速度快100倍, 2. 索引是占用磁盘的，每次DELETE、UPDATE以及INSERT都会触发索引磁盘有io. 8. 索引无法使用的情况（模糊匹配，OR 前后没有同时使用，联合索引的最左匹配等）； 1. MySQL只有对以下操作符才使用索引：!= <>不走索引 2. 可以在LIKE操作中使用索引的情形是指另一个操作数不是以通配符（%或者_）开头的情形 3. 没有单引号 is null,is not null 4. 使用了函数, or的2边也不走 事务 1. 事务类型 1. 扁平事务 2. 带有保存点的扁平事务 可以回滚到任意点 3. 链事务 只能回滚到当前的 4. 嵌套事务 5. 分布式事务 CAP 一致 可用 分区容错 2. 事务是如何实现的 1. 原子性、一致性、持久性通过数据库的redo log和undolog来完成 2. redo通常是物理日志，记录的是页的物理修改操作。undo是逻辑日志，根据每行记录进行记录。 3. 原理开始：排它锁-锁行，持久化数据到磁盘（redo/undo）,更新数据到磁盘，同步到binlog,如果回滚就是mvcc,提交就是redo,放锁，清除数据 3. ACID特性；一致（内存+磁盘），隔离（事务中不受干扰），原子（一起生死），持久（修改后不会改变） 4. 事务的并发问题（第一二类丢失更新，脏读，不可重复读，幻读）； 1. 第一类丢失更新:\b 未隔离的情况下，一起更新，一个异常导致另一个更新丢失 2. 第二类丢失更新: 是不可重复读的特殊情况,如果两个事务都读取同一行，两个都进行写操作，并提交，第一个事务所做的改变就会丢失。 3. 脏读：B事务查询A事务中还没提交的数据，形成脏读。 4. 不可重复读：事务上下文读取了同一个数据却不同，因为在这之间让更新了 5. 隔离级别（读未提交，读已提交，可重复读，串行化）； 1. 读未提交： 可以读到事务中未提交的数据。脏/不可重复读/幻 2. 读已提交： 事务中读取数据上下文不同。读到不同的数据。不可重复读/幻 3. 可重复读： 事务中允许读取到2次查询到的变更结果 1. 可重复读的隔离级别下使用了MVCC机制，select操作不会更新版本号，是快照读（历史版本）insert、update和delete会更新版本号，是当前读（当前版本） 2. 要避免幻读可以用间隙锁在Session _1下面执行update acc ount se t name ='zhuge'where i d&gt; 10and id&lt;= 20;，则其他Session没法插入这个范围内的数据 4. 串行化： id=1开启了事务，那么无法修改和查看 性能消耗，但是保证并发产生的问题 6. 数据库锁 查看思维导图 1. 锁的概念和大类别（MVCC 等）； 2. 数据库锁的类别（）； 1. 乐观锁:在更新时候认为你不会修改数据(update set stock =1 where id =1 and stock =2) 1. 一般的做法是在需要锁的数据上增加一个版本号，或者时间戳，类似CAS 2. 悲观锁/更新锁:锁定表或者行，让其他数据操作等待 selec * from where id =1 for update-（避免先S后X的死锁） 1. 读锁(共享锁):针对同一份数据，多个读操作可以同时进行而不会互相影响,不能进行写操作 2. 写锁(排他锁)当前写操作没有完成前，它会阻断其他写锁和读锁 3. 通常所说的“一锁二查三更新”即指的是使用悲观锁。通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。 3. 表锁：表锁偏向MyISAM存储引擎，开销小，加锁快，无思索，锁定粒度大，发生锁冲突的概率最高，并发度最低当前session对该表的增删改查都没有问题，他session对该表的所有操作被阻塞 4. 行锁：行锁偏向InnoDB存储引擎，开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 1. 行锁优化 1. 尽可能让所有数据检索都通过索引来完成，避免无索引行或索引失效导致行锁升级为表锁。 2. 尽可能避免间隙锁带来的性能下降，减少或使用合理的检索范围。 3. 尽可能减少事务的粒度，比如控制事务大小，而从减少锁定资源量和时间长度，从而减少锁的竞争等，提供性能。 4. 尽可能低级别事务隔离，隔离级别越高，并发的处理能力越低。 2. 行锁原理:锁定索引上的键值进行锁定 3. 行锁的3种算法： 1. Record Lock：单个行记录上的锁 2. Gap Lock：间隙锁，锁定一个范围，但不包含记录本身 1. 间隙锁:当我们用范围条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做\"间隙(GAP)\"。 1. 若执行的条件是范围过大，则InnoDB会将整个范围内所有的索引键值全部锁定，很容易对性能造成影响。 2. InnoDB也会对这个\"间隙\"加锁，这种锁机制就是所谓的间隙锁(Next-Key锁)。 3. Next-Key Lock∶Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身 1. 该锁是记录锁加gap锁，在RR隔离级别下，对行的扫描、锁定都是使用这种锁。如果查询中包含唯一索引，就会只适用记录锁。因为唯一索引能确定记录行数，其他索引不能确定行数，有可能在其他事务中添加这个索引的数据导致幻读。 5. 意向锁: （解决行表锁冲突）， 1. 意向共享锁（intention shared lock, IS）：事务有意向对表中的某些行加共享锁（S锁 1. SELECT column FROM table ... LOCK IN SHARE MODE; 2. 意向排他锁（intention exclusive lock, IX）：事务有意向对表中的某些行加排他锁（X锁） 1. SELECT column FROM table ... FOR UPDATE; 6. 记录锁-记录锁是锁住记录，锁住索引记录，而不是真正的数据记录 1. 锁是非主键索引，会在索引记录上加锁后，在去主键索引上加锁 2. 表上没有索引，会在隐藏的主键索引上加锁 3. 如果要锁的列没有索引，进行全表记录加锁 7. 死锁 1. 概念：主要是事物之间由于隔离级别最高，开启行锁，易造成相互持有对方的锁 2. 发生情况： 1. 一个线程两次申请锁 2. 两个线程互相申请对方的锁，但是对方都不释放锁。 3. 死锁产生的必要条件 1. 互斥：一次只有一个进程可以使用一个资源。其他进程不能访问已分配给其他进程的资源。 2. 占有且等待：当一个进程在等待分配得到其他资源时，其继续占有已分配得到的资源 3. 非抢占：不能强行抢占进程中已占有的资源。 4. 循环等待：存在一个封闭的进程链，使得每个资源至少占有此链中下一个进程所需要的一个资源。 4. 实现 1. _1执行：select *from account where i d= 1 for update;Session 2. _2执行：select *from account where i d= 2 for update;Session 3. _1执行：select *from account where i d= 2 for update;Session 4. _2执行：select *from account where i d= 1 for update; 5. 查看近期死锁日志信息：show engine inno db statu s\\G; 6. 一个线程两次申请锁。 1. 处理死锁的四种方法： 1. 死锁预防：通过确保死锁的一个必要条件不会满足，保证不会发生死锁 2. 死锁检测：允许死锁的发生，但是可以通过系统设置的检测结构及时的检测出死锁的发生，采取一些措施，将死锁清除掉 3. 死锁避免：在资源分配过程中，使用某种方法避免系统进入不安全的状态，从而避免发生死锁 4. 死锁解除：与死锁检测相配套的一种措施。当检测到系统中已发生死锁，需将进程从死锁状态中解脱出来。 2. 如何避免死锁： 1. 直接表锁 2. 一个事务尽可能一次锁定需要的数据， 3. 以相同的顺序访问表，可以大大降低死锁机会。 3. 加锁协议（一/二/三级加锁协议，二段锁协议（充分条件），一次封锁法等）； 1. 两段锁协议:一个事务中一旦开始释放锁，就不能再申请新锁了。事务的加锁和解锁严格分为两个阶段，第一阶段加锁，第二阶段解锁。 2. 封锁定理:如果事务是良构的且是两阶段的，那么任何一个合法的调度都是隔离的。 3. S2PL:在事务中只有提交(commit)或者回滚(rollback)时才是解锁阶段，其余时间为加锁阶段 4. 2PC，两阶段提交协议，用于分布式事务。 4. https://www.cnblogs.com/clschao/articles/10463743.html#part_1 7. OLTP与OLAP的介绍 https://www.cnblogs.com/clschao/articles/10463743.html#part_1 1. OLTP 系统强调数据库内存效率，强调内存各种指标的命令率，强调绑定变量，强调并发操作； 2. OLAP 系统则强调数据分析，强调SQL执行市场，强调磁盘I/O，强调分区等。 8. MVCC 的概念，时间戳版本号，快照版本与当前版本，适用场景等。 1. 隐含字段 1. DB_TRX_ID 6字节 事务id，随事务增加 2. DB_ROLL_PTR 7字节 回滚指针 3. DB_ROW_ID 隐藏的id，随记录自然增长 2. 过程 1. select 1. 当前session 事务版本号>=DB_TRX_ID 2. delete_id is null or 当前事务号 mysql分表 1. 分表策略 2. RANG 从0到10000一个表，10001到20000一个表； 1. 哈希取模 2. 比如按照华东，华南，华北这样来区分业务 3. 6个月一次 3. 分库分表后怎么保证主键仍然是递增的? 1. 预先获取自增id ，然后在插入各自的分表 2. UUID 主键性能查 ，导致b+树 结构修改导致效率变低 3. 时间戳+标识 4. snowflake算法:就是把一个 64 位的 long 型的 id，1 个 bit 是不用的，用其中的 41 bit 作为毫秒数，用 10 bit 作为工作机器 id，12 bit 作为序列号。 4. 分表的查询分页,利弊,分表下不同查询维度如何实现，最终引导除了双向表，得出分表了一个弊端，即数据冗余 1. 全局表：基础数据，所有库都拷贝一份,字段冗余 2. 分别查询出所有，然后组装起来，较复杂。 3. 中间件TDDL https://help.aliyun.com/document_detail/71252.html?spm=a2c4g.11186623.6.651.6cb92df5HwPNaR 慢查询、执行计划、sql优化 1. 慢查询：超过参数：long_query_time时间的sql-https://www.cnblogs.com/clschao/articles/10463743.html#part_1 1. slow_query_log 启动停止技术慢查询日志 2. slow_query_log_file 指定慢查询日志得存储路径及文件（默认和数据文件放一起） 3. long_query_time 指定记录慢查询日志SQL执行时间得伐值（单位：秒，默认10秒） 4. log_queries_not_using_indexes 是否记录未使用索引的SQL 5. log_output 日志存放的地方【TABLE】【FILE】【FILE,TABLE】 2. explain计划 1. 顺序 1. 表的读取顺序 2. 数据读取操作的操作类型 3. 哪些索引可以使用 4. 哪些索引被实际使用 5. 表之间的引用 6. 每张表有多少行被优化器查询 2. ID列：描述select查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序 1. id相同：执行顺序由上至下 2. id不同：如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行 3. id相同不同：同时存在 3. select_type列:查询的类型，要是用于区别:普通查询、联合查询、子查询等的复杂查询 1. SIMPLE:查询中不包含子查询或者UNION 2. PRIMARY：查询中若包含任何复杂的子部分，最外层查询则被标记为 3. SUBQUERY：在SELECT或WHERE列表中包含了子查询 4. DERIVED:在FROM列表中包含的子查询被标记为DERIVED(衍生) 5. UNION：若第二个SELECT出现在UNION之后，则被标记为UNION； 4. table列:显示这一行的数据是关于哪张表的 5. Type列:好到坏-得保证查询至少达到range级别，最好能达到ref。 +1 1. system>const>eq_ref>ref>range>index>ALL 2. System与const:System就一条 const-表示通过索引一次就找到了 3. eq_ref:唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描 4. Ref非唯一性索引扫描，返回匹配某个单独值的所有行. 5. Range:只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引 where 出现between、、in等的查询 6. Index:当查询的结果全为索引列的时候，虽然也是全部扫描，但是只查询的索引库，而没有去查询数据。 6. possible_keys:Key:实际使用的索引。如果为NULL，则没有使用索引 7. key_len:索引长度 越短越好 8. Ref:显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值 9. Extra列 1. Using where:列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候，mysql服务器将在存储引擎检索行后再进行过滤 2. Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询 3. Using filesort：MySQL中无法利用索引完成的排序操作称为“文件排序” 4. Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。 5. Impossible where：这个值强调了where语句会导致没有符合条件的行。 6. Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行 工程问题 mysql如果发生了抖动，怎么排查问题 https://www.jianshu.com/p/4f86680180a5 mysql 总结 https://www.jianshu.com/p/2530d1185778 mysql的数据页空洞是怎么造成的，如果解决，索引是局部还是全局的 有什么影响 删除数据时，空间并没有变小， mysql对数据库扫描时，扫描的对象实际是列表的容量上限，会降低扫描效率 概念 表空间： innodb 引擎存储的最高层； 存放所有的数据,删除了标记为 可复用就是数据空洞 独立表空间：Mysql 版本 5.6 后默认开启的单表单空间 Innodb 默认存储引擎页的大小为 16K ；默认表空间 大小为96k InnoDb 的数据存储类型是 B+树 ，B+树的叶子结点上 ，存储的是 数据页 ； 一页数据页存储的是 数据记录，假设一条数据记录占用 200字节 ，一页数据页大小为 16Kb ，那么一页可以存储80条数据记录 ，当某条数据记录，比如 ID = 300 的数据记录被删除了，实际上，引擎只会标记这条数据记录为删除，而不会将数据记录从磁盘上抹去，所以磁盘文件上的 ibd 文件不会缩小 所以删除和插入，其实是在数据页上，产生和填补空洞 的过程 ，经过删除更新插入的表，都可能会产生大量的空洞。 如何解决 myisam 可以使用 optimize table table_name 命令进行碎片整理，去除空洞，会锁表（innodb无法使用optimize） 使用 alter table table_name engine=innodb ，可以释放空洞，这是由于在转换数据引擎（即使没有真正转换）的时候，会将表中的所有数据读取，再重新写入，这个过程中，会释放空洞（效率慢） 在原表的基础上，压缩空间，去掉“可复用”空间。使用语句 optimize table t 奥特迈 CAP https://zhuanlan.zhihu.com/p/50990721 索引底层的数据结构？ +1 覆盖索引？+1 联合索引？+1 如何看SQL有没使用索引？ cardinaly +1 执行计划哪个字段表示索引？ +1 explain每个字段的意思？+1 type类型有哪些？ +1 发生抖动，如何排查问题？ +1 有哪些事务？+1 有哪些锁？+1 悲观锁和乐观锁什么区别？什么场景下使用？+1 乐观锁: 访问数据时不加锁，写数据时判断有无被其它线程或进程访问过。+1 场景: 多读 实现方式: 版本号和CAS算法 悲观锁: 访问数据时，先加锁，然后访问，最后释放锁。 可重复读？ +1 什么是幻读？ +1 如何解决幻读？+1 myisam和innodb区别？+1 redolog? +1 binlog? +1 undolog?+1 crash-safe? 主从过程+1 MVCC的实现？ +1 数据页空洞如何产生的？如何解决它？ +1 注入？如何解决？ SELECT USERNAME,PASSWORD FROM USER WHERE USERNAME='zrx' AND PASSWORD='aaa' or '1'='1'; 那么就是成功的 为什么用B+树不用B树？ B+树和红黑树有什么区别？ 数据库的知识点 说几种知道的索引。 mysql中你知道哪些优化方式。 mysql中innodb索引结构，B+树的特性。为什么使用B+树，不使用B树。 mysql的四种隔离级别。mysql的RR级别的隔离会产生幻读吗？如果不会是采用什么方式解决的呢？ innodb的RR隔离级别可以重复读，是采用的什么原理呢？MVCC是什么？ mysql集群，集群出现延迟如何解决。https://blog.csdn.net/miyatang/article/details/84397111 mysql的存储引擎innodb中的主级索引和二级索引是指什么？ "},"BaseNode/Php/php-题.html":{"url":"BaseNode/Php/php-题.html","title":"Php","keywords":"","body":" php 能不能做连接池的问题 对PHP变量的实现方式以及内存管理的梳理 http://onceme.me/post/php-memery/ PHP数组的底层实现 PHP是否适合做守护进程，为什么（内存管理这一块） PHP的垃圾回收机制 php导出，如果存在把内存打爆，怎么处理的 你觉得PHP相对比JAVA或者GO有什么异同 用时间切分进行算法上数据的调优 PHP源码的数组的排序是在底层源码哪里体现的。 状态码 499、502、504这些是在什么场景出现的，你有在实际项目中看到吗 PHP的FPM进程管理器的三种管理模式都有什么 php的hashtable foreach为什么比for循环快 php常用的运行模式有哪些，fpm和cli运行生命周期是什么和fpm模式中在进行fcgi-accept-request中如何解决惊群现象的，你知道nginx怎么解决惊群现象的，区别呢？ 你的PHP是怎么做安全处理的，比如SQL注入、xss、csrf "},"BaseNode/Redis/Redis-题.html":{"url":"BaseNode/Redis/Redis-题.html","title":"Redis","keywords":"","body":"redis有没有用过，常用的数据结构以及在业务中使用的场景。 redis的hash怎么实现的？ rehash过程讲一下和JavaHashMap的rehash有什么区别？ redis cluster有没有了解过，怎么做到高可用的？ 说说redis的持久化机制，为啥不能用redis做专门的持久化数据库存储？ 考虑redis的时候，有没有考虑容量？大概数据量会有多少？ Redis 的 list zset 的底层实现 Redis连接时的connect与pconnect的区别 Redis有哪些结构时间复杂度较高 Redis hash的实现 redis的sentinel上投票选举的问题 raft算法 缓存命中率 概述 1、什么是Redis 2、Redis有哪些优缺点 3、为什么要用 Redis /为什么要用缓存 4、为什么要用 Redis 而不用 map/guava 做缓存? 5、Redis为什么这么快 数据类型 1、Redis有哪些数据类型 2、Redis的应用场景 持久化 1、什么是Redis持久化？ 2、Redis 的持久化机制是什么？各自的优缺点？ 3、如何选择合适的持久化方式 4、Redis持久化数据和缓存怎么做扩容？ 5、过期键的删除策略 6、Redis的过期键的删除策略 7、Redis key的过期时间和永久有效分别怎么设置？ 8、我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢? 内存相关 1、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据 2、Redis的内存淘汰策略有哪些 3、Redis主要消耗什么物理资源？ 4、Redis的内存用完了会发生什么？ 5、Redis如何做内存优化？ 线程模型 1、Redis线程模型 事务 1、什么是事务？ 2、Redis事务的概念 3、Redis事务的三个阶段 4、Redis事务相关命令 5、事务管理（ACID）概述 6、Redis事务支持隔离性吗 7、Redis事务保证原子性吗，支持回滚吗 8、Redis事务其他实现 集群方案 1、哨兵模式 2、官方Redis Cluster 方案(服务端路由查询) 3、基于客户端分配 4、基于代理服务器分片 Redis 主从架构 1、Redis集群的主从复制模型是怎样的？ 2、生产环境中的 redis 是怎么部署的？ 3、说说Redis哈希槽的概念？ 4、Redis集群会有写操作丢失吗？为什么？ 5、Redis集群之间是如何复制的？ 6、Redis集群最大节点个数是多少？ 7、Redis集群如何选择数据库？ 分区 1、Redis是单线程的，如何提高多核CPU的利用率？ 2、为什么要做Redis分区？ 3、你知道有哪些Redis分区实现方案？ 4、Redis分区有什么缺点？ 分布式问题 1、Redis实现分布式锁 2、如何解决 Redis 的并发竞争 Key 问题 3、分布式Redis是前期做还是后期规模上来了再做好？为什么？ 4、什么是 RedLock 缓存异常 1、缓存雪崩 2、缓存穿透 3、缓存击穿 4、缓存预热 5、缓存降级 6、热点数据和冷数据 7、缓存热点key 常用工具 1、Redis支持的Java客户端都有哪些？官方推荐用哪个？ 2、Redis和Redisson有什么关系？ 3、Jedis与Redisson对比有什么优缺点？ 其他问题 1、Redis与Memcached的区别 2、如何保证缓存与数据库双写时的数据一致性？ 3、Redis常见性能问题和解决方案？ 4、Redis官方为什么不提供Windows版本？ 5、一个字符串类型的值能存储最大容量是多少？ 6、Redis如何做大量数据插入？ 7、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？ 8、使用Redis做过异步队列吗，是如何实现的 9、Redis如何实现延时队列 10、Redis回收进程如何工作的？ 11、Redis回收使用的是什么算法？ 答案如下 什么是Redis Redis(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的（BSD许可）高性能非关系型（NoSQL）的键值对数据库。 Redis 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。 与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。 Redis有哪些优缺点 优点： 读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。 支持数据持久化，支持AOF和RDB两种持久化方式。 支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。 数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。 缺点： 数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。 Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。 Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。 "}}