#### 二叉树

   1. 概念	
      1. 先序：考察到一个节点后，即刻输出该节点的值，并继续遍历其左右子树。(根左右)
      2. 中序：考察到一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树。(左根右) 二叉搜索树中序是有序的
      3. 后序：考察到一个节点后，将其暂存，遍历完左右子树后，再输出该节点的值。(左右根)
   2. 方式
      1. 递归改变节点输出位置即可
      2. 用栈：
   3. 递归

### 分治 回溯

1. 分治

   1. 递归的一种，找重复性，分解问题 PS(因为计算机只会干 if 、else、for、loop)
   2. 代码模版
      1. 正常的泛型递归
      2. 结果组装一起，公司架构一样拆分下去

   

   2. 回溯
      1. 不断在每一层区试，8皇后问题、n个括号组
      2. 代码模版
         1. 归去来兮感觉

   

### 深度和广度搜索

   1. 搜索每个节点访问一次，仅仅访问一次 保证效率

   2. 深度不同

      1. 深度优先 DFS

         1. 递归，判断是否访问过，节点放到已访问里，继续递归。竖的左到右

         2. 不等循环走完，会循环下一层的 

            > **熟练记模版**

      2. 广度优先 BFS

         1. 使用队列，水波纹一样，最短路求 一层一层的 横的

         2. Queue + 循环

            > **熟练记模版**

      3. 优先级优先-现实场景-启发式场景-深度学习范畴

   

### 贪心算法

1. 贪心：希望导致全局最好，最优  。当下选择最好最优（只顾眼前）不可退

   1. 最优，最近，最好，高效、最小深层树。工程不实用，但是可以当辅助算法
   2. 需要证明可以得到贪心的，如果是能整除
   3. 难度在你怎么证明可以用贪心。实际较少
   4. 代码 排序，
   5. 股票买卖最佳时机

2. 动态规划：会保存以前运算结果，适当时候可以回退

   

   

   ### 二分查找

   1. 单调性（递增，递减，上下界），有序里进行查找

   2. 索引下标访问，

      > **代码模板**

   ### 动态规划

   1. 分治：模板 - 纸上写，效果更好

      1. 数学归纳法：n=1,n=2想明白 n成立 如何n+1 
      2. 本质：寻找重复性，树形结合的概念图

   2. 动态规划

      > 概念： 是有最优子结构->动态递推->将一个复杂的问题 分解成简单的子问题
      >
      > 1. 缓存，状态存储数组，淘汰次状态，保留最优状态



### 字典数，并查集

	1. 字典树：常用字符的往下走，不断分流 ten  t->te->ten
 	2. 节点不存完整的单词，路过的节点组合起来就是目地字符串
 	3. 浏览器搜索:ten
 	4. 实现一个trie

