
关系数据库

##### 范式
1. 要求有主键，并且要求每一个字段原子性不可再分
   1. 即主键唯一，字段不要有137，138这种
2. 要求所有非主键字段完全依赖主键，不能产生部分依赖
   1. 多对多关系不在一张表里
3. 所有非主键字段和主键字段之间不能产生传递依赖
   1. 学生id ->班级id -> 班级名称不行
##### Mysql和inno的一些概念
1. mysql组成-一个实例可能多个数据库，也可能1对1-一个单进程多线程架构的数据库 ，一个进程一个实例
	1. 连接池组件
    2. 管理服务和工具组件
	3. SQL接口组件
	4. 查询分析器组件
	5. 优化器组件
	6. 缓冲（Cache）组件
	7. 插件式存储引擎
	8. 物理文件
2. Inno引擎
    1. Inno后台线程：体系架构(缓存池)
       1. Master Thread:主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO页的回收等。2.5节会详细地介绍各个版本中Master Thread的工作方式。
       2. IO Thread:使用了AIO（Async IO）来处理写IO请求，这样可以极大提高数据库的性能
       3. Purge Thread:事务被提交后，其所使用的undolog可能不再需要，因此需要PurgeThread来回收已经使用并分配的undo页
       4. Page Cleaner Thread:其作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成。而其目的是为了减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能。
    2. 内存
	    1. 缓冲池
		    1. 基于磁盘存储，以分页的形式
		    2. 缓冲池的大小直接影响着数据库的整体性能。由于32位操作系统的限制，在该系统下最多将该值设置为3G。
			3. 强烈建议数据库服务器都采用64位的操作系统。innodb_buffer_pool_size来设置
	    2. 内存区域进行管理
      		1. 缓冲池是通过LRU（Latest Recent Used，最近最少使用

---
##### 数据结构
1. B+ 树的好处
---
##### 索引
    1. 为什么使用b+树
       1. 单一节点存储更多元素，减少IO，非叶子节点只是存储key，占用空间非常小方便直观
       2. 所有查询都要找到叶子节点，查询稳定
       3. 所有叶子节点形成有序链表，方便范围查询,而且对应物理磁盘的指针顺序
    2. 哈希索引；
        1. 哈希自适应索引 InnoDB特性:
           1. 插入缓存，
           2. 2次写入，
           3. 哈希自适应索引
           4. 异步I/O
           5. 刷新领接页
        2. 优先主键是哈希，因为inno的数据是基于主键索引上，并且领接页面是有序的，对应磁盘上的位置
        3. 如果没主键，那么第一个非空唯一索引是主键
        4. 如果都没有，会自动创建一个字节为6的隐藏主键当聚集哈希索引
    3. 聚簇索引/非聚簇索引；
       1. innoDB是B+树的数据结构，叶子节点上的都是整行数据,聚集索引直接通过键值找到叶子节点上的数据,索引数据和物理数据顺序是一致的不能2个
       2. 非聚集索引是通过非聚索引的键值找到节点上的值，在找到行数据.
    4. Cardinality
       1. show index from xxx表， 其中Cardinality /行数 越接近1那么索引效果越好,但是这是一个预估值
       2. 原理是通过随机抽取8个数据节点算出来的
       3. 算法是：非叶子节点数量N 对应节点数量是p1~p8 那么公示就是Cardinality=（p1+p...+p8）* n/8
       4. 数据变化超过1/16时候，或者配置项变更超过200W次
    5. 联合索引；
       1. 不同二级索引区别，是有多个索引项s
       2. 联合索引也是一个B+树
       3. ab查询ok a查询ok b查询不ok
       4. 联合索引ab的b是排序好的，如果用联合索引进行排序可以减少排序成本
    6. 覆盖索引；
       1. 最左匹配情况下，一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。Extra有Using index 数据全走索引
       2. select 和where都走到索引，不需要回表在查询数据 减少io 
    7. 索引优缺点（加快检索速度，加快多表连接，额外空间开销，维护索引的额外时间开销）；
       1. 速度快100倍,
       2. 索引是占用磁盘的，每次DELETE、UPDATE以及INSERT都会触发索引磁盘有io.
    8.  索引无法使用的情况（模糊匹配，OR 前后没有同时使用，联合索引的最左匹配等）；
        1.  MySQL只有对以下操作符才使用索引：!= <>不走索引
        2.  可以在LIKE操作中使用索引的情形是指另一个操作数不是以通配符（%或者_）开头的情形
        3.  没有单引号 is null,is not null
        4.  使用了函数, or的2边也不走

---
##### 事务
    1. 事务类型
       1. 扁平事务
       2. 带有保存点的扁平事务 可以回滚到任意点
       3. 链事务 只能回滚到当前的
       4. 嵌套事务
       5. 分布式事务 CAP 一致 可用 分区容错
    2. 事务是如何实现的
       1. 原子性、一致性、持久性通过数据库的redo log和undolog来完成
       2. redo通常是物理日志，记录的是页的物理修改操作。undo是逻辑日志，根据每行记录进行记录。
       3. 原理开始：排它锁-锁行，持久化数据到磁盘（redo/undo）,更新数据到磁盘，同步到binlog,如果回滚就是mvcc,提交就是redo,放锁，清除数据
    3. ACID特性；一致（内存+磁盘），隔离（事务中不受干扰），原子（一起生死），持久（修改后不会改变）
    4. 事务的并发问题（第一二类丢失更新，脏读，不可重复读，幻读）；
        1. 第一类丢失更新: 未隔离的情况下，一起更新，一个异常导致另一个更新丢失
        2. 第二类丢失更新: 是不可重复读的特殊情况,如果两个事务都读取同一行，两个都进行写操作，并提交，第一个事务所做的改变就会丢失。
        3. 脏读：B事务查询A事务中还没提交的数据，形成脏读。
        4. 不可重复读：事务上下文读取了同一个数据却不同，因为在这之间让更新了
    5. 隔离级别（读未提交，读已提交，可重复读，串行化）；
       1. 读未提交： 可以读到事务中未提交的数据。脏/不可重复读/幻
       2. 读已提交： 事务中读取数据上下文不同。读到不同的数据。不可重复读/幻
       3. 可重复读： 事务中允许读取到2次查询到的变更结果
          1. 可重复读的隔离级别下使用了MVCC机制，select操作不会更新版本号，是快照读（历史版本）insert、update和delete会更新版本号，是当前读（当前版本）
          2. 要避免幻读可以用间隙锁在Session   _1下面执行update  acc  ount se t name  ='zhuge'where i d&gt; 10and id&lt;= 20;，则其他Session没法插入这个范围内的数据
       4. 串行化： id=1开启了事务，那么无法修改和查看 性能消耗，但是保证并发产生的问题
    6. 数据库锁 查看思维导图
       1. 锁的概念和大类别（MVCC 等）；
       2. 数据库锁的类别（）； 
           1. 乐观锁:在更新时候认为你不会修改数据(update set stock =1 where id =1 and stock =2)
              1. 一般的做法是在需要锁的数据上增加一个版本号，或者时间戳，类似CAS
           2. 悲观锁/更新锁:锁定表或者行，让其他数据操作等待 selec  * from where id =1 for update-（避免先S后X的死锁）
      	       1. 读锁(共享锁):针对同一份数据，多个读操作可以同时进行而不会互相影响,不能进行写操作
      	       2. 写锁(排他锁)当前写操作没有完成前，它会阻断其他写锁和读锁
      	       3. 通常所说的“一锁二查三更新”即指的是使用悲观锁。通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。
           3. 表锁：表锁偏向MyISAM存储引擎，开销小，加锁快，无思索，锁定粒度大，发生锁冲突的概率最高，并发度最低当前session对该表的增删改查都没有问题，他session对该表的所有操作被阻塞 
           4. 行锁：行锁偏向InnoDB存储引擎，开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
              1. 行锁优化
                1. 尽可能让所有数据检索都通过索引来完成，避免无索引行或索引失效导致行锁升级为表锁。
                2. 尽可能避免间隙锁带来的性能下降，减少或使用合理的检索范围。
                3. 尽可能减少事务的粒度，比如控制事务大小，而从减少锁定资源量和时间长度，从而减少锁的竞争等，提供性能。
                4. 尽可能低级别事务隔离，隔离级别越高，并发的处理能力越低。
              2. 行锁原理:锁定索引上的键值进行锁定
              3. 行锁的3种算法：
                 1. Record Lock：单个行记录上的锁
                 2. Gap Lock：间隙锁，锁定一个范围，但不包含记录本身
                     1. 间隙锁:当我们用范围条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做"间隙(GAP)"。
                        1.  若执行的条件是范围过大，则InnoDB会将整个范围内所有的索引键值全部锁定，很容易对性能造成影响。
                        2.  InnoDB也会对这个"间隙"加锁，这种锁机制就是所谓的间隙锁(Next-Key锁)。
                 3. Next-Key Lock∶Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身
                    1. 该锁是记录锁加gap锁，在RR隔离级别下，对行的扫描、锁定都是使用这种锁。如果查询中包含唯一索引，就会只适用记录锁。因为唯一索引能确定记录行数，其他索引不能确定行数，有可能在其他事务中添加这个索引的数据导致幻读。
           5. 意向锁: （解决行表锁冲突），
              1. 意向共享锁（intention shared lock, IS）：事务有意向对表中的某些行加共享锁（S锁 
                 1. SELECT column FROM table ... LOCK IN SHARE MODE;
              2. 意向排他锁（intention exclusive lock, IX）：事务有意向对表中的某些行加排他锁（X锁）
                 1. SELECT column FROM table ... FOR UPDATE;
           6.  记录锁-记录锁是锁住记录，锁住索引记录，而不是真正的数据记录
               1.  锁是非主键索引，会在索引记录上加锁后，在去主键索引上加锁
               2.  表上没有索引，会在隐藏的主键索引上加锁
               3.  如果要锁的列没有索引，进行全表记录加锁
           7.  死锁
               1.  概念：主要是事物之间由于隔离级别最高，开启行锁，易造成相互持有对方的锁
               2.  发生情况：
                   1.  一个线程两次申请锁
                   2.  两个线程互相申请对方的锁，但是对方都不释放锁。
               3. 死锁产生的必要条件
                  1. 互斥：一次只有一个进程可以使用一个资源。其他进程不能访问已分配给其他进程的资源。
                  2. 占有且等待：当一个进程在等待分配得到其他资源时，其继续占有已分配得到的资源
                  3. 非抢占：不能强行抢占进程中已占有的资源。
                  4. 循环等待：存在一个封闭的进程链，使得每个资源至少占有此链中下一个进程所需要的一个资源。
               4.  实现
                   1.  _1执行：select *from account where i d= 1  for update;Session 
                   2.  _2执行：select *from account where i d= 2  for update;Session   
                   3.  _1执行：select *from account where i d= 2  for update;Session   
                   4.  _2执行：select *from account where i d= 1  for update;
                   5.  查看近期死锁日志信息：show engine inno   db  statu  s\G;
                   6.  一个线程两次申请锁。
                1. 处理死锁的四种方法：
                   1. 死锁预防：通过确保死锁的一个必要条件不会满足，保证不会发生死锁
                   2. 死锁检测：允许死锁的发生，但是可以通过系统设置的检测结构及时的检测出死锁的发生，采取一些措施，将死锁清除掉
                   3. 死锁避免：在资源分配过程中，使用某种方法避免系统进入不安全的状态，从而避免发生死锁
                   4. 死锁解除：与死锁检测相配套的一种措施。当检测到系统中已发生死锁，需将进程从死锁状态中解脱出来。
                2. 如何避免死锁：
                   1. 直接表锁
                   2. 一个事务尽可能一次锁定需要的数据，
                   3. 以相同的顺序访问表，可以大大降低死锁机会。
       3.  加锁协议（一/二/三级加锁协议，二段锁协议（充分条件），一次封锁法等）；
           1.  两段锁协议:一个事务中一旦开始释放锁，就不能再申请新锁了。事务的加锁和解锁严格分为两个阶段，第一阶段加锁，第二阶段解锁。
           2.  封锁定理:如果事务是良构的且是两阶段的，那么任何一个合法的调度都是隔离的。
           3.  S2PL:在事务中只有提交(commit)或者回滚(rollback)时才是解锁阶段，其余时间为加锁阶段
           4.  2PC，两阶段提交协议，用于分布式事务。
       4.  https://www.cnblogs.com/clschao/articles/10463743.html#part_1
    7.  OLTP与OLAP的介绍 https://www.cnblogs.com/clschao/articles/10463743.html#part_1
        1.  OLTP 系统强调数据库内存效率，强调内存各种指标的命令率，强调绑定变量，强调并发操作；
        2.  OLAP 系统则强调数据分析，强调SQL执行市场，强调磁盘I/O，强调分区等。 
    8.  MVCC 的概念，时间戳版本号，快照版本与当前版本，适用场景等。
        1.  隐含字段 
            1.  DB_TRX_ID 6字节 事务id，随事务增加
            2.  DB_ROLL_PTR 7字节 回滚指针
            3.  DB_ROW_ID 隐藏的id，随记录自然增长
        2. 过程
	        1. select 
      	        1. 当前session 事务版本号>=DB_TRX_ID
      	        2. delete_id is null or 当前事务号<DB_TRX_ID
   	        1. insert:新插入的行，DB_TRX_ID=当前事务号
   	        2. update:更新行的时候，InnoDB会把原来行复制一份，DB_TRX_ID=当前事务号
   	        3. delete
      	        1. 设置删除版本号为当前事务id (DB_TRX_ID=当前事务号??) delete_id = 当前事务号
      	        2. 相当于标记为删除，而不是物理的删除。真是的删除是在InnoDB的purge线程去做的。
   	        4. commit:修改事务状态为commit,在 redo log 中写入 commit 记录
   	        5. rollback:根据当前回滚指针从undo log中找出事务修改前的版本，并恢复
	
		
	
		
		
	
		
	
		

--- 
##### mysql分表
    1. 分表策略
    2. RANG 从0到10000一个表，10001到20000一个表；
        1. 哈希取模
        2. 比如按照华东，华南，华北这样来区分业务
        3. 6个月一次
    3. 分库分表后怎么保证主键仍然是递增的?
        1. 预先获取自增id ，然后在插入各自的分表
        2. UUID 主键性能查 ，导致b+树 结构修改导致效率变低
        3. 时间戳+标识
        4. snowflake算法:就是把一个 64 位的 long 型的 id，1 个 bit 是不用的，用其中的 41 bit 作为毫秒数，用 10 bit 作为工作机器 id，12 bit 作为序列号。
    4. 分表的查询分页,利弊,分表下不同查询维度如何实现，最终引导除了双向表，得出分表了一个弊端，即数据冗余
        1. 全局表：基础数据，所有库都拷贝一份,字段冗余
        2. 分别查询出所有，然后组装起来，较复杂。
        3. 中间件TDDL https://help.aliyun.com/document_detail/71252.html?spm=a2c4g.11186623.6.651.6cb92df5HwPNaR

---
##### 慢查询、执行计划、sql优化 
    1. 慢查询：超过参数：long_query_time时间的sql-https://www.cnblogs.com/clschao/articles/10463743.html#part_1
       1. slow_query_log 启动停止技术慢查询日志
       2. slow_query_log_file 指定慢查询日志得存储路径及文件（默认和数据文件放一起）
       3. long_query_time 指定记录慢查询日志SQL执行时间得伐值（单位：秒，默认10秒）
       4. log_queries_not_using_indexes  是否记录未使用索引的SQL
       5. log_output 日志存放的地方【TABLE】【FILE】【FILE,TABLE】
    2. explain计划
       1. 顺序
          1. 表的读取顺序
          2. 数据读取操作的操作类型
          3. 哪些索引可以使用
          4. 哪些索引被实际使用
          5. 表之间的引用
          6. 每张表有多少行被优化器查询
        2. ID列：描述select查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序
           1. id相同：执行顺序由上至下
           2. id不同：如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
           3. id相同不同：同时存在
        3. select_type列:查询的类型，要是用于区别:普通查询、联合查询、子查询等的复杂查询
           1. SIMPLE:查询中不包含子查询或者UNION
           2. PRIMARY：查询中若包含任何复杂的子部分，最外层查询则被标记为
           3. SUBQUERY：在SELECT或WHERE列表中包含了子查询
           4. DERIVED:在FROM列表中包含的子查询被标记为DERIVED(衍生)
           5. UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；
        4. table列:显示这一行的数据是关于哪张表的
        5. Type列:好到坏-得保证查询至少达到range级别，最好能达到ref。 +1
           1. system>const>eq_ref>ref>range>index>ALL
           2. System与const:System就一条 const-表示通过索引一次就找到了
           3. eq_ref:唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描
           4. Ref非唯一性索引扫描，返回匹配某个单独值的所有行.
           5. Range:只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引 where 出现between、<、>、in等的查询
           6. Index:当查询的结果全为索引列的时候，虽然也是全部扫描，但是只查询的索引库，而没有去查询数据。
        6. possible_keys:Key:实际使用的索引。如果为NULL，则没有使用索引
        7. key_len:索引长度 越短越好
        8. Ref:显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值
        9. Extra列
            1. Using where:列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候，mysql服务器将在存储引擎检索行后再进行过滤
            2. Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询
            3. Using filesort：MySQL中无法利用索引完成的排序操作称为“文件排序”
            4. Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。
            5. Impossible where：这个值强调了where语句会导致没有符合条件的行。
            6. Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行


---
##### 工程问题
1. mysql如果发生了抖动，怎么排查问题 
    https://www.jianshu.com/p/4f86680180a5
2. mysql 总结
    https://www.jianshu.com/p/2530d1185778
3. mysql的数据页空洞是怎么造成的，如果解决，索引是局部还是全局的
   1. 有什么影响
      1. 删除数据时，空间并没有变小，
      2. mysql对数据库扫描时，扫描的对象实际是列表的容量上限，会降低扫描效率
   2. 概念
      1. 表空间： innodb 引擎存储的最高层； 存放所有的数据,删除了标记为 可复用就是数据空洞
      2. 独立表空间：Mysql 版本 5.6 后默认开启的单表单空间
      3. Innodb 默认存储引擎页的大小为 16K ；默认表空间 大小为96k
      4. InnoDb 的数据存储类型是 B+树 ，B+树的叶子结点上 ，存储的是 数据页 ； 
         1. 一页数据页存储的是 数据记录，假设一条数据记录占用 200字节 ，一页数据页大小为 16Kb ，那么一页可以存储80条数据记录 ，当某条数据记录，比如 ID = 300 的数据记录被删除了，实际上，引擎只会标记这条数据记录为删除，而不会将数据记录从磁盘上抹去，所以磁盘文件上的 ibd 文件不会缩小
         2. 所以删除和插入，其实是在数据页上，产生和填补空洞 的过程 ，经过删除更新插入的表，都可能会产生大量的空洞。
   3. 如何解决
      1. myisam 可以使用 optimize table table_name 命令进行碎片整理，去除空洞，会锁表（innodb无法使用optimize）
      2. 使用 alter table table_name engine=innodb ，可以释放空洞，这是由于在转换数据引擎（即使没有真正转换）的时候，会将表中的所有数据读取，再重新写入，这个过程中，会释放空洞（效率慢）
      3. 在原表的基础上，压缩空间，去掉“可复用”空间。使用语句 optimize table t 奥特迈
4. CAP https://zhuanlan.zhihu.com/p/50990721

索引底层的数据结构？ +1
覆盖索引？+1
联合索引？+1
如何看SQL有没使用索引？ cardinaly +1
执行计划哪个字段表示索引？  +1
explain每个字段的意思？+1
type类型有哪些？ +1
发生抖动，如何排查问题？ +1
有哪些事务？+1
有哪些锁？+1
悲观锁和乐观锁什么区别？什么场景下使用？+1
乐观锁: 访问数据时不加锁，写数据时判断有无被其它线程或进程访问过。+1
场景: 多读
实现方式: 版本号和CAS算法
悲观锁: 访问数据时，先加锁，然后访问，最后释放锁。
可重复读？ +1
什么是幻读？ +1
如何解决幻读？+1
myisam和innodb区别？+1
redolog? +1
binlog? +1
undolog?+1
crash-safe? 主从过程+1
MVCC的实现？ +1
数据页空洞如何产生的？如何解决它？ +1

注入？如何解决？
> SELECT USERNAME,PASSWORD FROM USER WHERE USERNAME='zrx' AND PASSWORD='aaa' or '1'='1'; 那么就是成功的
> 
为什么用B+树不用B树？ 
B+树和红黑树有什么区别？
数据库的知识点
1. 说几种知道的索引。
2. mysql中你知道哪些优化方式。
3. mysql中innodb索引结构，B+树的特性。为什么使用B+树，不使用B树。
4. mysql的四种隔离级别。mysql的RR级别的隔离会产生幻读吗？如果不会是采用什么方式解决的呢？ innodb的RR隔离级别可以重复读，是采用的什么原理呢？MVCC是什么？
5. mysql集群，集群出现延迟如何解决。https://blog.csdn.net/miyatang/article/details/84397111
6. mysql的存储引擎innodb中的主级索引和二级索引是指什么？