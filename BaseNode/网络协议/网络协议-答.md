1. OSI七层模型？
   1. 应用层；表示层；会话层；传输层；网络层；数据链路层；物理层；
   3. DHCP协议是什么？使用什么端口？他的优劣？
      1. 动态主机配置协议
      2. 客户端端口：68；服务端端口：67
      3. 如果发生IP冲突则返回DHCP decline
   6. 网络序是大端还是小端？为什么要这样？
      1. 主机序：不同的CPU有不同的字节序类型 整数在内存中保存的顺序 这个叫做主机序
      2. 网络序：是TCP/IP中规定好的一种数据格式，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传
         2. 网络序是大端的，按内存增长的顺序,高位数据存在低内存中 大端
   7. 操作系统原理，套接字
      1. 操作系统内容，操作系统调用系统函数，访问系统内核或设备会返回一个fd句柄，根据句柄来获取操作。
      2. 套接字
            1. TCP套接字是由一个四元组（源IP地址、源端口号，目的IP地址，目的端口号）来标识的
            2. 操作系统网络，系统会为我们创建一个套接字Socket，并返回这个Socket的ID，操作网络只要向这个Socket的编号ID操作即可。每一个网络通信的进程至少对应着一个Socket。向Socket的ID中写数据，相当于向网络发送数据，向Socket中读数据，相当于接收数据。而且这些套接字都有唯一标识符——端口号。
   8. 应用层协议：
      1. 1、超文本传输协议（HTTP）:万维网的基本协议；
      2. 2、文件传输（FTP简单文件传输协议）；
      3. 3、远程登录（Telnet），提供远程访问其它主机功能, 它允许用户登录internet主机，并在这台主机上执行命令；
      4. 4、网络管理（SNMP简单网络管理协议），该协议提供了监控网络设备的方法， 以及配置管理,统计信息收集,性能管理及安全管理等；
      5. 5、域名系统（DNS），该系统用于在internet中将域名及其公共广播的网络节点转换成IP地址。
   9.  网络层
      6.  1、Internet协议（IP）；
      7.  2、Internet控制信息协议（ICMP）；
      8.  3、地址解析协议（ARP）；
          1.  ARP协议。
              1.  地址解析协议， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址。
              2.  上层应用程序更多关心IP地址而不关心MAC地址，所以需要通过ARP协议来获知目的主机的MAC地址，完成数据封装。
      9.  4、反向地址解析协议（RARP）。
2. 概念
   1. IP 地址子网划分。5类
      1. A类 1.0.0.0 掩码8
      2. B类 128.0.0.0 掩码16
      3. C类 192.0.0.0 掩码24
   2. Mac 地址  
      1. 物理地址/硬件地址，固定不变，在链路层，十六进制长度是6个字节（48位），分为前24位和后24位。
   3. IP地址与MAC地址区别
      1. 长度不同：IP地址为32位（二进制），MAC地址为48位（十六进制）。
      2. 分配依据不同：IP地址的分配是基于网络拓扑，MAC地址的分配是基于制造商。
      3. 寻址协议层不同：IP地址应用于OSI第三层（网络层），而MAC地址应用在OSI第二层（数据链路层）。
   4. 硬链接和软连接区别
      1. 硬链接：linux下的文件是通过索引节点（Inode）来识别文件，硬链接是一个指针，指向文件索引节点，系统并不为它重新分配inode。每添加一个一个硬链接，文件的链接数就加1。
         1. 不足之处：（1）不可以在不同文件系统的文件间建立链接（2）只有超级用户才可以为目录创建硬链接。
      2. 软连接
         1. 软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。
   5. 用户数据，元数据 (metadata)。
         1. 用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方；
         2. 元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。才是文件的唯一标识而非文件名
   6. DNS 解析过程。
      1. DNS:
         1. 客户端以udp的数据包形式发送
         2. 本地host是否存在映射
         3. 本地不存在映射->查询本地->根域名->顶级->二级->权威
      2. dns迭代和递归的区别?
         1. 递归是用户只向本地DNS服务器发出请求，然后等待肯定或否定答案。本地dns会问其他服务然后返回答案
         2. 迭代是本地服务器向根DNS服务器发出请求，而根DNS服务器只是给出下一级DNS服务器的地址，然后本地DNS服务器再向下一级DNS发送查询请求直至得到最终答案。
   7. kill 用法，某个进程杀不掉的原因（进入内核态，忽略 kill 信号）
      1. 僵死进程->详见进程
      2. 进入内核态，忽略所有信号
   8. RPC相对于传统的API调用的优点
      1. HTTP 请求有用的信息少，头太多,普通话，大而全
      2. RPC，序列化数据，是json和xml，地方化，专业精准
   9.  fork如何区分父子进程
       1. 父进程从fork()返回时的返回值是子进程的进程号，非零；
   10. 知道什么是幂等性吗？举个例子？
       1.  防重点击：其任意多次执行所产生的影响均与一次执行的影响相同。
       2.  比如select,delete,唯一索引，各种锁，状态机
   11. VPN的实现原理是什么
       1.  虚拟私有网络。,打隧道，做路由的过程！


3. Linux
   1. 路由表一般包含什么？
      1. （1）网络地址（2）网络掩码（3）网关【下一跳服务器】（4）跃点数【距离】
   4. ping命令的实现原理，ping命令为什么不需要端口号呢?  ICMP协议查看远程服务器的原理。
      1. 原理是向指定的IP地址发送一定长度的数据包，成功返回，时间内失败超时
      2. ICMP协议:“Internet Control Message Protocol”（Internet控制消息协议），是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息
      3. ICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。


4.  TCP/UDP
    1.  TCP
        1. 概念
            1.  TCP/IP提供了点对点链接的机制，将数据应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。、
            2.  它将软件通信过程抽象化为四个抽象层（包括应用层,传输层，网络层，网络访问层。），
            3.  采取协议堆栈的方式，分别实现出不同通信协议。
        2. 名称解释
           1. 序列号seq： 序列号seq就是这个报文段中的第一个字节的数据编号。
           2. 确认号ack： 报文段最后一个字节的编号+1即为确认号。
           3. 确认ACK： 仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效
           4. 同步SYN： 连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。
           5.  终止FIN： 用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接
        3. TCP-传输控制协议 过程
           1. 第一次握手：主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B，向主机B 请求建立连接，通过这个数据段， 主机A告诉主机B 两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我。
           2. 第二次握手：主机B 收到主机A的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机A，也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我
              1. TCP如果两次握手会出什么问题？
                 1. 两次握手：客户端发送的连接请求可能在网络中滞留了，如果没有三次握手，可能会再次创建一个连接。
           3. 第三次握手：主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B 的数据段："我已收到回复，我现在要开始传输实际数据了，这样3次握手就完成了，主机A和主机B 就可以传输数据了。

        4. 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？
           1. 第三次握手时候，客户端发送一个finsh报文，服务端回复ack应答，
           2. 当数据传输完成后，才会发送一个finsh完成包给客户端，客户端关闭连接
        5. 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？
           1. 最大报文生存时间 服务端最后一次ack 可能丢失 ，所以需要这个time_wait等待防止丢失 可以重发。
        6. Tcp为什么可以保证传输的可靠性
           1. 应用数据被分割成TCP认为最适合发送的数据块。这和UDP完全不同，应用程序产生的数据报长度将保持不变 (将数据截断为合理的长度)
           2. 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。        
           3. 序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。
              1. tcp怎么保证有序传输的，
                 1. TCP就给每个数据包分配一个序列号并且在一个特定的时间内等待接收主机对分配的这个序列号进行确认，如果发送主机在一个特定时间内没有收到接收主机的确认，则发送主机会重传此数据包。接收主机利用序列号对接收的数据进行确认，以便检测对方发送的数据是否有丢失或者乱序等，接收主机一旦收到已经顺序化的数据，它就将这些数据按正确的顺序重组成数据流并传递到高层进行处理
           4. 超时重传
           5. 连接管理：三次握手与四次挥手的过程
           6. 流量控制
           7. 拥塞控制
              1. tcp拥塞机制-（慢开始，拥塞避免，超时重传，快速重传/快速恢复算法）
              2. 计算机网络中的带宽、交换节点中的缓存和处理机等，都是网络的资源，在某段时间内，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏，这种情况就叫做拥塞。
              3. 拥塞控制，就是防止过多的数据注入到网络中，拥塞控制是一个全局性的过程，涉及到所有的
              4. 拥塞控制的算法有：
                 1. 慢开始:慢开始算法的核心是从小到大逐渐增大发送窗口，cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。
                 2. 拥塞避免：让拥塞窗口缓慢地增大，收到每一轮的确认后，将拥塞窗口的值加1，而不是加倍，这样拥塞窗口的值按照线性规律缓慢增长。
                 3. 超时重传：发送一个数据以后就开启一个计时器，在一定时间内如果没有得到发送数据报的ACK报文，那么就重新发送数据，直到发送成功为止
                    1. 这是数据包丢失的情况下给出的一种修补机制
                 4. 快速重传/快速恢复算法：一般来说，重传发生在超时之后，但是如果发送端接收到3个以上的重复ACK，而快速重传以后，因为走的不是慢启动而是拥塞避免算法，所以这又叫做快速恢复算法。
                 5. PS:没有快速重传和快速恢复，TCP将会使用定时器来要求传输暂停,在暂停这段时间内，没有新的数据包被发送。

           7. TCP协议通过使用连续ARQ协议和滑动窗口协议，来保证数据传输的正确性，从而提供可靠的传输。
              1. ARQ协议 即自动重传请求（Automatic Repeat-reQuest），是OSI模型中数据链路层和传输层的错误纠正协议之一。ARQ包括停止等待ARQ协议和连续ARQ协议，
                 1. 停止等待协议
                    1. 超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。
                    2. 优点是简单,但是缺点是信道的利用率太低,一次发送一条消息,使得信道的大部分时间内都是空闲的,
                    3. 因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。
                    4. 缺点：停止等待ARQ协议的优点是简答，但也有很严重的确定，就是信道利用率太低
                 2. 连续ARQ协议:
                    1. 连续确认ARQ和滑动窗口是配合一起使用的：
                    3. 连续发出5个数据包，接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了，提高信道利用率
                    4. 但是如果缺少了其中一个是需要将其他的全部重发，当通信质量不是很好的时候,连续ARQ还是会带来负面影响.
                 3. 滑动窗口协议:之所以叫滑动窗口协议,是因为窗口是不断向前走的,该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输,还可以控制流量的问题.
              2. ARQ协议 机制
                 1. 拥有错误检测（Error Detection）、
                 2. 正面确认（Positive Acknowledgment）、
                 3. 超时重传（Retransmission after Timeout）和 
                 4. 负面确认及重传（Negative Acknowledgment and Retransmission）等机制


           8. tcp 粘包问题怎么处理？
                    1. TCP是一个基于字节流的传输服务，"流"意味着TCP所传输的数据是没有边界的
                    2. 产生粘包问题的原因有以下几个：
                        1.  如果发送方发送的多个分组本来就是同一个数据的不同部分，比如一个很大的文件被分成多个分组发送，这时，当然不需要处理粘包的现象；
                        2.  但如果多个分组本毫不相干，甚至是并列的关系，我们就一定要处理粘包问题了。
                    3. 粘包的问题的解决思路
                       1. 粘包问题的最本质原因在与接收对等方无法分辨消息与消息之间的边界在哪。
                       2. 粘包解决方案一：使用定长包，如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。
                       3. 粘包解决方案二：使用结构体，显式说明数据部分的长度，包尾加上\r\n标记。FTP协议正是这么做的。但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界。
                       4. 粘包解决方案三：按行读取，ftp协议采用/r/n来识别一个消息的边界，我们在这里实现一个按行读取的功能，该功能能够按/n来识别消息的边界。这里介绍一个函数：

            1. 那三次握手又会造成什么问题？有什么好的解决方法没？
               1.  三次握手：引起SYN flood DOS攻击
                   1. 在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。
                   2. SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。
                   3. 检测 SYN 攻击非常的方便，半连接状态，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。
                   4. SYN攻击不能完全被阻止，常见的防御 SYN 攻击的方法有如下几种
                      1. 增加积压队列
                      2. 回收最早的半开TCP连接: 增加最大半连接数，”伤敌一千，自损八百“
                      3. SYN cookie：把发送ack的请求缓存住，并且删除缓冲队列里的请求，等确认是合法的后回复这个请求


    2. UDP
       1. 概念
          1. UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，传送时抓取来自应用程序的数据，并扔到网络上
          2. UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。
          3. 一台服务机可同时向多个客户机传输相同的消息。
          4. UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。
          5. UDP是面向报文的
          6. ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包， 如果数据包是否到达的消息及时反馈回来，那么网络就是通的。
          7. 包头都是16位
       2.  UDP应用场景：
           1. 面向数据报文方式
           2. 网络数据大多为短消息 
           3. 拥有大量Client
           4. 对数据安全性无特殊要求
           5. 网络负担非常重，但对响应速度要求高
       3.  udp是不可靠的传输，如果你来设计一个基于udp差不多可靠的算法，怎么设计？
           1.  特点
              1.  Tcp 面向连接，提供可靠的传输； UDP面向无连接，提供不可靠传输
              2.  Tcp 提供流量控制 ； UDP不提供流量控制
              3.  Tcp 保证传输数据顺序 ； UDP不保证传输顺序，也就是可能是乱序收包
              4.  TCP 面向字节流 ； UDP 面向数据包
           2. 设计思路
              1.  数据完整性 –> 加上一个16或者32位的CRC验证字段
              2.  乱序 –> 加上一个数据包序列号SEQ
              3.  丢包 –> 需要确认和重传机制，就是和Tcp类似的Ack机制
              4.  协议字段 –> protol 字段，标识当前使用协议
    3. 小结TCP与UDP的区别：
       1. TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
       2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
       3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
       4. UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
       5. 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
       6. TCP首部开销20字节;UDP的首部开销小，只有8个字节
       7. TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

       12. 应用场景
          1. TCP应用场景:效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。
          2. UDP应用场景
             1. 效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）
 
   5.  time_wait状态，这个状态出现在什么地方，有什么用？
       1.  time_wait状态
           1.  保证TCP协议全双工连接能够可靠关闭，直接关闭的话，如果服务器没有收到ACK，会重复发FIN
           2.  保证连接的重复数据从网络中消失，如果上次的socket和这次的socket处理的程序一样，就会导致这次连接把上次的数据加进来了。
           3.  假设最终的ACK丢失，主机2将重发FIN，主机1必须维护TCP状态信息以便可以重发最终的ACK，否则会发送RST，结果主机2认为发生错误。
           4.  TCP实现必须可靠地终止连接的两个方向(全双工关闭)，主机1必须进入 TIME_WAIT 状态，因为主机1可能面 临重发最终ACK的情形。
       2. 产生大量TIME_WAIT的原因
          1. 某些服务如pop/smtp、ftp
          2. 客户端程序忘记关闭连接，也会出现TIME_WAIT的状态。
          3. 一般情况服务器端不会出现TIME_WAIT状态，因为大多数情况都是客户端主动发起连接并主动关闭连接
       3. 出现太多TIME_WAIT可能导致的后果
          1. 持续的到达一定量的高并发短连接，会使服务器因端口资源不足而拒绝为一部分客户服务。
          2. 而端口有个0~65535的范围，并不是很多，刨除系统和其他服务要用的，剩下的就更少了。
       4. TIME_WAIT太多怎么解决?
          1. 解决发起端的IP地址,添加更多的IP(time_wait多的服务器)
          2. 改用长链接方式
          3. 让TIME_WAIT早点过期，修改配置
   6.  close_wait过多该如何解决。 https://blog.csdn.net/lishenglong666/article/details/45335589
      1. 在被动关闭连接情况下，在已经接收到FIN，但是还没有发送自己的FIN的时刻，连接处于CLOSE_WAIT状态。
      2. 出现大量close_wait的现象，主要原因是某种情况下对方关闭了socket链接，但是我方忙与读或者写，没有关闭连接。代码需要判断socket，一旦读到0，断开连接，read返回负，检查一下errno，如果不是AGAIN，就断开连接。
   7.  TCP 保活机制（SO_KEEPALIVE 超时重发 
        3.  RTT，RTO
            1.  RTT:一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值,
            2.  RTO:重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传, RTO协议实现值最小1s
            3.  底层的网络是不可靠的
         1. 信道利用率太低，每次都需要等上一次ACK包接收到了才能再次发送

5.  HTTP/https
   8.  http与https有啥区别？说下https解决了什么问题，怎么解决的？说下https的握手过程。
      1.  区别
           1. https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
           5. HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。前者是80，后者是443
           6. HTTPS协议握手阶段比较费时，缓存资源
      2. https过程
         1. 客户端发起HTTPS请求
         2. 服务端的配置，增加证书，私钥，公钥
         3. 传送证书
         4. 客户端解析证书
         5. 传送加密信息
         6. 服务段解密信息
         7. 传输加密后的信息
         8. 客户端解密信息
         9. 搜索引擎对HTTPS的态度
         10. HTTPS要比HTTP多用多少服务器资源？
           1. HTTP使用TCP三次握手建立连接，客户端和服务器需要交换3个包
           2. HTTPS除了TCP的三个包，还要加上ssl握手需要的9个包，所以一共是12个包。
   10. HTTP请求过程（从URL输入到页面展现发生什么？）
       1. DNS解析过程
       2. 拿到ip后使用 ARP地址解析协议协议，拿到目标IP对应的MAC地址，完成数据封装
       3. 经过osi七层协议，物理层、数据链路层、网络层、传输层、会话层、表示层和应用层
       4. web服务器，返回数据
       5. 传输完成，第三次握手挥手关闭请求
   11. Http1.0与1.1区别
       1.  缓存处理，
           1.  HTTP1.0 header里的If-Modified-Since,Expires来做为缓存判断的标准，
           2.  HTTP1.1 更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
       2.  带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
       3.  错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
       4.  Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
       5.  长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。
       6.  
   12. Http2.0的特性
       1.  二进制分帧
       2.  首部压缩
       3.  流量控制
       4.  多路复用
       5.  请求优先级
       6.  服务器推送

DNS
迭代查询  浏览器缓存记录  、本地host文件记录  、本地的DNS服务器
递归查询  根服务器  顶级域名、二级域名、权威服务器
逐层封装 tcp->ip->数据链路层(首部mac) 帧 ->比特流  -> 经过路由根据ip转发 ->  ip解析到mac地址。  逐层拆解。
tcp三次握手过程    建立http连接
https、http
建立https连接 （TLS/SSL握手）
1 客户端发送请求，支持的加密协议到服务端 、 服务端返回公钥和证书到客户端
2 客户端证书验证 生成对称密钥随机数  公钥对其加密,发送到服务端
3 服务器私钥解密发来的公钥，用公钥加密数据。建立通信
http重定向 状态码 等
浏览器通过解析HTML，生成DOM树，解析CSS，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树。渲染树。重排重绘。
